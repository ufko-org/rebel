<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Rebel Guide</title>
  
  <link rel="stylesheet" href="docs.css">
  
  <script type="application/ld+json">{"@context":"https://schema.org","@type":"ProgrammingLanguage","name":"Rebel","alternateName":"Rebel Language","description":"Rebel is a pragmatic general-purpose scripting language written in ANSI C with a lean lisp-like syntax.","url":"https://rebel-lang.org","creator":{"@type":"Person","name":"Ufko (ufko.org)"},"license":"https://opensource.org/license/gpl-3-0","programmingLanguage":"ANSI C","sameAs":["https://github.com/ufko-org/rebel","https://ufko.org"]}</script>
  <link rel="icon" href="/logo_v0.svg" type="image/svg+xml">
</head>
<body>
  <table>
    <tr>
      <td rowspan="2" class="logo">
        <a href="/index.html">
          <img src="logo_v0.svg" alt="Rebel">
        </a>
      </td>
      <td><a href="/guide.html">Guide</a></td>
      <td><a href="/patterns.html">Patterns</a></td>
      <td><a href="/reference.html">Reference</a></td>
      <td><a href="https://github.com/ufko-org/rebel">Code</a></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
  </table>
  <hr>
  <h1 id="rebel-guide-wip">Rebel Guide (WIP)</h1>
<hr/>
<p>Copyright &#169; 2025 Ufko (ufko.org)</p>
<p>This manual is released under the MIT license.
You may use, copy, modify and distribute it freely,
provided that this notice is preserved.</p>
<hr/>
<h2 id="table-of-contents-summary-of-chapters">Table of Contents (Summary of Chapters)</h2>
<p>TOC</p>
<h2 id="philosophy-and-design-goals">Philosophy and Design Goals</h2>
<p>Rebel is a small, sharp, and transparent language.  Its
design follows a few strict ideas: no abstraction for
abstraction’s sake, no hidden state, no complex machinery
behind simple constructs.  Everything visible in code
corresponds directly to something happening in the
interpreter.</p>
<p>Rebel is deliberately minimal.  It avoids features that add
convenience at the cost of clarity.  The goal is to provide
a predictable core that encourages disciplined thinking and
precise programming.</p>
<h3 id="minimal-surface-area">Minimal Surface Area</h3>
<p>Rebel has very few concepts:</p>
<ul>
<li>symbols</li>
<li>lists</li>
<li>sequences</li>
<li>functions</li>
<li>contexts</li>
<li>evaluation rules</li>
</ul>
<p>These make up almost the entire language.  There are no
classes, packages, generics, annotations, attributes,
decorators, or other layers that multiply mental overhead.
The interpreter stays small because the language stays
small.</p>
<h3 id="direct-execution-model">Direct Execution Model</h3>
<p>Expressions follow strict and uniform evaluation rules.
There is no syntax hiding behavior, no operator precedence,
and no implicit coercion.  What you write is what gets
evaluated.</p>
<p>An expression is always one of two things:</p>
<ul>
<li>a literal value<br/></li>
<li>a list representing a function call<br/></li>
</ul>
<p>Because of this, reading Rebel code is the same as
understanding how the interpreter will execute it.</p>
<h3 id="unix-thinking">Unix Thinking</h3>
<p>Rebel is shaped by the same principles as classic Unix tools:</p>
<ul>
<li>composition over frameworks<br/></li>
<li>transparency over convenience<br/></li>
<li>simplicity over cleverness<br/></li>
<li>predictable failure modes<br/></li>
<li>explicit control over environment and processes<br/></li>
</ul>
<p>Every system-level feature—files, sockets, processes,
pipes—maps directly to the underlying OS.  There are no
wrappers that “simplify” things by hiding details.  If a
user needs deeper control, nothing is in the way.</p>
<h3 id="no-magic-no-automatic-behavior">No Magic, No Automatic Behavior</h3>
<p>Rebel avoids “smart” features that guess what the programmer wants:</p>
<ul>
<li>no automatic type conversions<br/></li>
<li>no overloading<br/></li>
<li>no implicit state changes<br/></li>
<li>no silent fallbacks<br/></li>
<li>no special-case syntax paths<br/></li>
</ul>
<p>Every function does one thing.  When something fails, it
fails loudly, without restructuring control flow or
rewriting values behind the scenes.</p>
<h3 id="everything-is-inspectable">Everything is Inspectable</h3>
<p>Rebel treats code as data.  Any expression can be inspected,
transformed, stored, or executed.  The interpreter does not
protect internal details or hide the structure of
definitions.  Functions, contexts, and whole programs can be
introspected or modified at runtime if needed.</p>
<h3 id="consistent-data-model">Consistent Data Model</h3>
<p>Lists, strings, and arrays form a unified class of
sequences.  Most sequence functions work identically across
all three.  This reduces exceptions and special cases,
making the system easier to reason about.</p>
<p>Closures, contexts, and FOOP objects follow the same rules and require no
special syntax.</p>
<h3 id="sharp-rather-than-safe">Sharp Rather Than Safe</h3>
<p>Rebel does not try to prevent mistakes.  It does not sandbox
the user, it does not enforce “safety patterns,” and it does
not attempt to save the programmer from incorrect
assumptions.</p>
<p>The philosophy is simple:</p>
<ul>
<li>Provide clear tools.</li>
<li>Let the programmer decide how to use them.</li>
<li>Do not interfere.</li>
</ul>
<h3 id="designed-for-people-who-think-slowly-and-carefully">Designed for People Who Think Slowly and Carefully</h3>
<p>Rebel favors deliberate, thoughtful programming.  The
language does not encourage rapid hacks or “clever” tricks.
It supports the programmer who prefers clarity,
explicitness, and control.</p>
<p>The core priority is <strong>understanding</strong>, not convenience.</p>
<h3 id="summary">Summary</h3>
<p>Rebel’s design is guided by:</p>
<ul>
<li>minimal concepts<br/></li>
<li>explicit execution<br/></li>
<li>Unix transparency<br/></li>
<li>no hidden behavior<br/></li>
<li>strong introspection<br/></li>
<li>unified data structures<br/></li>
<li>trust in the programmer<br/></li>
</ul>
<p>The result is a language that is small, predictable, and
extremely direct — a precise tool rather than a platform.</p>
<h2 id="running-rebel-and-working-in-the-repl">Running Rebel and Working in the REPL</h2>
<p>Rebel can be used in two modes:</p>
<ol>
<li>as an interactive REPL (read–eval–print loop)</li>
<li>as a script interpreter for <code>.rbl</code> files</li>
</ol>
<p>Both modes use the same evaluation rules.<br/>
The REPL simply evaluates expressions line by line.</p>
<h3 id="starting-the-repl">Starting the REPL</h3>
<p>From a terminal:</p>
<pre><code>$ rebel
</code></pre>
<p>Check available options:</p>
<pre><code>$ rebel -h
</code></pre>
<p>You will see a prompt:</p>
<pre><code>&#62;
</code></pre>
<h3 id="running-a-script-file">Running a Script File</h3>
<p>To execute a <code>.rbl</code> file:</p>
<pre><code>$ rebel script.rbl
</code></pre>
<p>Arguments:</p>
<pre><code>$ rebel script.rbl arg1 arg2
</code></pre>
<p>Inside the program:</p>
<pre><code>(main-args)
; -&#62; ("script.rbl" "arg1" "arg2")
</code></pre>
<h3 id="preventing-auto-repl-after-script-execution">Preventing Auto-REPL After Script Execution</h3>
<p>By default, Rebel <strong>drops into the REPL</strong> after running a
script.  There are two ways to avoid this:</p>
<ol>
<li>Explicitly exit at the end of the script:</li>
</ol>
<pre><code>(exit)
</code></pre>
<ol start="2">
<li>Or run the interpreter in quiet mode:</li>
</ol>
<pre><code>$ rebel -q script.rbl
</code></pre>
<h3 id="using-rebel-as-an-executable-script">Using Rebel as an Executable Script</h3>
<p>Add a shebang:</p>
<pre><code>#!&#47;usr&#47;bin&#47;env rebel
(println "running")
</code></pre>
<p>Make it executable:</p>
<pre><code>$ chmod +x script.rbl
$ .&#47;script.rbl
</code></pre>
<h3 id="initialization-file">Initialization File</h3>
<p>If present, Rebel automatically loads:</p>
<pre><code>~&#47;.init.rbl
</code></pre>
<p>This file may contain helper functions, prompt settings, or
custom startup code.</p>
<h3 id="reloading-code-during-development">Reloading Code During Development</h3>
<p>Load modules or utility files into the REPL:</p>
<pre><code>(load "utils.rbl")
</code></pre>
<p>When the file changes, simply load it again.<br/>
Rebel evaluates it fresh each time.</p>
<h3 id="customizing-the-prompt">Customizing the Prompt</h3>
<pre><code>(prompt-event (lambda () "rebel&#62; "))
</code></pre>
<h3 id="debugging-tools">Debugging Tools</h3>
<ul>
<li><code>trace</code> — prints function calls<br/></li>
<li><code>pretty-print</code> — formatted output<br/></li>
<li><code>history</code> — call history for functions<br/></li>
<li><code>dump</code> — internal cell information (advanced)</li>
</ul>
<p>Enable tracing:</p>
<pre><code>(trace true)
</code></pre>
<h3 id="inspecting-values">Inspecting Values</h3>
<pre><code>(args func)
(source func)
(symbols &#39;Ctx)
</code></pre>
<h3 id="handling-errors">Handling Errors</h3>
<pre><code>&#62; (&#47; 1 0)
division by zero error
&#62;
</code></pre>
<p>Inspect last error:</p>
<pre><code>(last-error)
</code></pre>
<h3 id="resetting-and-exiting">Resetting and Exiting</h3>
<p>Reset to top-level:</p>
<pre><code>(reset)
</code></pre>
<p>Exit REPL:</p>
<pre><code>(exit)
</code></pre>
<p>or press <strong>Ctrl+D</strong>.</p>
<h3 id="running-external-commands">Running External Commands</h3>
<pre><code>(! "ls -l")
</code></pre>
<h3 id="practical-tips">Practical Tips</h3>
<ul>
<li>Keep functions in <code>.rbl</code> files and reload them during development.</li>
<li>Use <code>.init.rbl</code> for personal configuration.</li>
<li>Use <code>rebel -q</code> for scripting-only mode.</li>
<li>Use <code>trace</code> sparingly; it is verbose.</li>
<li>For persistent data, use <code>write-file</code> or <code>save</code>.</li>
</ul>
<h3 id="summary-1">Summary</h3>
<p>Rebel’s execution model is straightforward:</p>
<ul>
<li>run scripts: <code>rebel script.rbl</code><br/></li>
<li>run without entering REPL: <code>rebel -q script.rbl</code> or call <code>(exit)</code><br/></li>
<li>start interactive REPL: <code>rebel</code><br/></li>
<li>view options: <code>rebel -h</code><br/></li>
<li>configure startup in <code>~&#47;.init.rbl</code><br/></li>
</ul>
<p>Everything remains minimal and predictable.</p>
<h2 id="the-basics">The Basics</h2>
<p>Rebel uses a simple and uniform syntax based on classic Lisp
s-expressions.  Everything in the language is built from the
same structural idea:</p>
<pre><code>(operator arg-1 arg-2 ...)
</code></pre>
<p>The first element specifies what to do.  The remaining
elements are arguments, which may be numbers, strings,
lists, symbols, or nested expressions.</p>
<p>This gives Rebel a single core representation for both code
and data.</p>
<h3 id="evaluation">Evaluation</h3>
<p>Rebel evaluates expressions using a predictable rule:</p>
<ol>
<li>evaluate the first element<br/></li>
<li>this must produce a function or primitive<br/></li>
<li>evaluate all remaining elements<br/></li>
<li>call the function with the evaluated arguments</li>
</ol>
<p>Example:</p>
<pre><code>(+ 1 2) ; -&#62; 3
</code></pre>
<p>There are no hidden rules, no operator precedence, and no
special syntax beyond a few core forms.</p>
<h3 id="symbols">Symbols</h3>
<p>A symbol is a named value:</p>
<pre><code>(set &#39;x 10)
</code></pre>
<p>The symbol now refers to the number 10:</p>
<pre><code>(+ x 5) ; -&#62; 15
</code></pre>
<p>Symbols can store any kind of value: numbers, strings,
lists, functions, contexts, or even other symbols.</p>
<h3 id="quote">Quote</h3>
<p>Without quoting, every list is treated as code.<br/>
Quoting prevents evaluation:</p>
<pre><code>&#39;(+ 1 2)
</code></pre>
<p>This returns the list literally, without executing it.<br/>
The long form is:</p>
<pre><code>(quote (+ 1 2))
</code></pre>
<h3 id="lists">Lists</h3>
<p>Lists are fundamental data structures.<br/>
A literal list:</p>
<pre><code>&#39;(1 2 3)
</code></pre>
<p>Created at runtime:</p>
<pre><code>(list 1 2 3)
</code></pre>
<h3 id="basic-operations">Basic operations:</h3>
<pre><code>(first &#39;(a b c)) ; -&#62; a
(rest  &#39;(a b c)) ; -&#62; (b c)
(cons 1 &#39;(2 3))  ; -&#62; (1 2 3)
(append &#39;(1 2) &#39;(3 4)) ; -&#62; (1 2 3 4)
</code></pre>
<p>Lists may contain mixed types:</p>
<pre><code>&#39;(1 "x" (2 3) nil)
</code></pre>
<h3 id="strings">Strings</h3>
<p>Strings use double quotes:</p>
<pre><code>"hello world"
</code></pre>
<p>Strings behave like sequences:</p>
<pre><code>(first "abc") ; -&#62; "a"
(rest  "abc") ; -&#62; "bc"
</code></pre>
<p>Many sequence functions work on both lists and strings.</p>
<h3 id="functions">Functions</h3>
<p>Functions are defined either with <code>define</code>:</p>
<pre><code>(define (square x) (* x x))
</code></pre>
<p>Or explicitly using <code>lambda</code>:</p>
<pre><code>(set &#39;square (lambda (x) (* x x)))
</code></pre>
<p>Calling a function:</p>
<pre><code>(square 5) ; -&#62; 25
</code></pre>
<h3 id="nested-expressions">Nested Expressions</h3>
<p>Expressions can be nested freely:</p>
<pre><code>(+ (* 2 3) (* 4 5)) ; -&#62; 26
</code></pre>
<p>Evaluation proceeds from the innermost expression outward.</p>
<h3 id="conditionals">Conditionals</h3>
<p>The basic conditional form is:</p>
<pre><code>(if cond expr-true expr-false)
</code></pre>
<p>Example:</p>
<pre><code>(if (&#62; x 0)
    "positive"
    "non-positive")
</code></pre>
<h3 id="blocks">Blocks</h3>
<p>Multiple expressions can be evaluated in sequence with <code>begin</code>:</p>
<pre><code>(begin
  (set &#39;x 10)
  (set &#39;y 20)
  (+ x y)) ; -&#62; 30
</code></pre>
<p>The value of the entire block is the value of its last expression.</p>
<h3 id="dynamic-evaluation">Dynamic Evaluation</h3>
<p>Because code is represented as lists, it can be built and evaluated dynamically:</p>
<pre><code>(set &#39;expr &#39;(+ 1 2))
(eval expr) ; -&#62; 3
</code></pre>
<h3 id="destructive-functions">Destructive Functions</h3>
<p>Some Rebel functions modify an existing value in place, while others return a
new value without touching the original.  Functions that update data directly
are called <em>destructive</em>.  Examples include operations that insert, remove, or
overwrite elements inside a list, string, or array.</p>
<p>When a function such as <code>push</code> or <code>replace</code> is described as destructive, it
means that the target object is changed immediately and the symbol referring to
it now points to the updated value.  Non-destructive functions leave the
original value untouched and instead produce a modified copy.</p>
<p>In practice this distinction matters when you rely on persistent data or when
multiple symbols point to the same structure.  Destructive updates affect all
references to that structure, while non-destructive ones do not.</p>
<h3 id="comments">Comments</h3>
<p>Comments begin with a semicolon or #, the semicolon is
prefered:</p>
<pre><code># this is a comment
; this is a comment
(set &#39;x 1) ; assigns x
</code></pre>
<h3 id="summary-2">Summary</h3>
<p>The core ideas of Rebel are:</p>
<ul>
<li>uniform s-expression syntax<br/></li>
<li>simple evaluation rules<br/></li>
<li>no distinction between code and data<br/></li>
<li>minimal special forms<br/></li>
<li>predictable structure<br/></li>
<li>functional composition by nesting</li>
</ul>
<p>This foundation keeps the language small, transparent, and
expressive.</p>
<h2 id="flow-control">Flow Control</h2>
<p>Flow control in Rebel is built from a small set of primitives that follow the
same evaluation rules as any other expression.  There is no special syntax and
no operator precedence.  Each form is a simple s-expression that directs the
execution of other expressions.</p>
<p>The key building blocks are conditional evaluation, branching, iteration, and
block construction.</p>
<h3 id="conditionals-if-when-unless">Conditionals: if, when, unless</h3>
<p>The basic conditional is <code>if</code>, which evaluates one of two expressions depending
on the result of a test:</p>
<pre><code>(if cond expr-then expr-else)
</code></pre>
<p>Example:</p>
<pre><code>(if (&#62; x 0)
    "positive"
    "non-positive")
</code></pre>
<p><code>when</code> executes its body only when the condition is true:</p>
<pre><code>(when (= x 1)
  (println "x is 1"))
</code></pre>
<p><code>unless</code> is the inverse: it executes when the condition is false.</p>
<pre><code>(unless (= x 0)
  (println "x is not zero"))
</code></pre>
<h3 id="multi-branch-cond-and-case">Multi-branch: cond and case</h3>
<p><code>cond</code> selects the first clause whose condition is true:</p>
<pre><code>(cond
  ((&#60; x 0)  "negative")
  ((= x 0)  "zero")
  (true     "positive"))
</code></pre>
<p><code>case</code> compares a value against multiple keys:</p>
<pre><code>(case x
  (1 "one")
  (2 "two")
  (3 "three")
  (true "other"))
</code></pre>
<h3 id="sequential-execution-begin-and-silent">Sequential Execution: begin and silent</h3>
<p><code>begin</code> evaluates its expressions in order and returns the value of the last
one:</p>
<pre><code>(begin
  (set &#39;a 10)
  (set &#39;b 20)
  (+ a b)) ; -&#62; 30
</code></pre>
<p><code>silent</code> behaves like <code>begin</code> but suppresses console output.<br/>
It is useful in REPL automation and scripts.</p>
<h3 id="loops-for-dotimes-while-until-do-while-do-until">Loops: for, dotimes, while, until, do-while, do-until</h3>
<p>A simple counted loop:</p>
<pre><code>(for (i 1 5)
  (println i))
</code></pre>
<p><code>dotimes</code> iterates a fixed number of times:</p>
<pre><code>(dotimes (i 3)
  (println i))
</code></pre>
<p><code>while</code> repeats while the condition is true:</p>
<pre><code>(set &#39;x 5)
(while (&#62; x 0)
  (println x)
  (dec x))
</code></pre>
<p><code>until</code> repeats until the condition becomes true:</p>
<pre><code>(set &#39;x 0)
(until (= x 3)
  (println x)
  (inc x))
</code></pre>
<p><code>do-while</code> and <code>do-until</code> always execute the body at least once:</p>
<pre><code>(do-while
  (println x)
  (&#62; x 0))
</code></pre>
<pre><code>(do-until
  (println x)
  (= x 5))
</code></pre>
<h3 id="iterators-doargs-dolist-dostring-dotree">Iterators: doargs, dolist, dostring, dotree</h3>
<p>Rebel provides iteration forms that work directly over structured data.</p>
<p><strong>Arguments of a function:</strong></p>
<pre><code>(define (show-args)
  (doargs (x)
    (println "arg:" x)))

(show-args 10 "a" &#39;(1 2))  ; prints each argument
</code></pre>
<p><strong>List iteration:</strong></p>
<pre><code>(dolist (x &#39;(10 20 30))
  (println x))
</code></pre>
<p><strong>String iteration (character-by-character):</strong></p>
<pre><code>(dostring (ch "abc")
  (println ch))
</code></pre>
<p><strong>Context iteration:</strong></p>
<pre><code>(dotree (sym MyContext)
  (println sym))
</code></pre>
<h3 id="logical-flow-and-or-not">Logical Flow: and, or, not</h3>
<p>These forms evaluate left to right and stop as soon as the result is known.</p>
<pre><code>(and true 1)       ; -&#62; 1
(and nil  x y)     ; -&#62; nil
(or  nil "x")      ; -&#62; "x"
(not true)         ; -&#62; nil
</code></pre>
<h3 id="error-control-catch-and-throw">Error Control: catch and throw</h3>
<p><code>catch</code> evaluates an expression and intercepts errors or explicit <code>throw</code>:</p>
<pre><code>(catch
  (begin
    (&#47; 1 0))
  "division error")
</code></pre>
<p>Explicit non-local exits:</p>
<pre><code>(catch
  (throw 99 "fail")
  "unused") ; never reached
</code></pre>
<p>The return value of <code>throw</code> becomes the result of the enclosing <code>catch</code>.</p>
<h3 id="summary-3">Summary</h3>
<p>Flow control in Rebel is minimal but expressive:</p>
<ul>
<li>if &#47; when &#47; unless for basic branching<br/></li>
<li>cond &#47; case for multi-way dispatch<br/></li>
<li>begin &#47; silent for sequencing<br/></li>
<li>for &#47; dotimes &#47; while &#47; until &#47; do-* for loops<br/></li>
<li>dolist &#47; dostring &#47; doargs &#47; dotree for iteration over structures<br/></li>
<li>and &#47; or &#47; not for logical flow<br/></li>
<li>catch &#47; throw for error handling and non-local exits</li>
</ul>
<p>This minimal set covers both simple scripts and complex recursive programs with
uniform, predictable behavior.</p>
<h2 id="lists-1">Lists</h2>
<p>Lists are the core data structure used throughout Rebel.
They provide a flexible way to represent sequences of
values, program structure, trees, and arbitrary composite
objects.  A list is written as a parenthesized sequence of
elements:</p>
<pre><code>&#39;(a b c)
</code></pre>
<p>Rebel treats lists uniformly—there is no difference between
a list that represents data and a list that represents code.
Evaluation rules determine whether a list is executed or
returned as a literal value.</p>
<h3 id="creating-lists">Creating Lists</h3>
<p>Lists can be created in two main ways:</p>
<p>Literal (quoted):</p>
<pre><code>&#39;(1 2 3)
</code></pre>
<p>Constructed at runtime:</p>
<pre><code>(list 1 2 3)
</code></pre>
<p>A list may contain mixed types:</p>
<pre><code>&#39;(1 "x" (2 3) nil)
</code></pre>
<h3 id="accessing-elements">Accessing Elements</h3>
<p>Basic selectors:</p>
<pre><code>(first &#39;(a b c)) ; -&#62; a
(rest  &#39;(a b c)) ; -&#62; (b c)
</code></pre>
<p>These operations return new values and do not modify the
original list.</p>
<h3 id="building-lists">Building Lists</h3>
<p>Prepending using <code>cons</code>:</p>
<pre><code>(cons &#39;x &#39;(y z)) ; -&#62; (x y z)
</code></pre>
<p>Appending two lists:</p>
<pre><code>(append &#39;(1 2) &#39;(3 4)) ; -&#62; (1 2 3 4)
</code></pre>
<h3 id="length-and-indexing">Length and Indexing</h3>
<p>Length of a list:</p>
<pre><code>(length &#39;(a b c d)) ; -&#62; 4
</code></pre>
<p>Access by zero-based index:</p>
<pre><code>(nth 2 &#39;(a b c d)) ; -&#62; c
</code></pre>
<h3 id="modifying-lists">Modifying Lists</h3>
<p>Some operations update the list in place.<br/>
These are destructive:</p>
<ul>
<li>push</li>
<li>pop</li>
<li>replace</li>
<li>swap</li>
</ul>
<p>Example:</p>
<pre><code>(set &#39;lst &#39;(1 2 3))
(push &#39;x lst)  ; lst becomes (x 1 2 3)
(pop lst)      ; returns x, lst becomes (1 2 3)
</code></pre>
<p>Destructive operations affect all symbols referencing the
same list.  Non-destructive functions return new lists
without altering the original.</p>
<h3 id="nested-lists-and-trees">Nested Lists and Trees</h3>
<p>Lists naturally form tree structures:</p>
<pre><code>&#39;(a (b (c d)) e)
</code></pre>
<p>Useful functions for nested lists:</p>
<ul>
<li>flat       — flatten nested structure</li>
<li>ref        — retrieve an element by a path of indices</li>
<li>ref-all    — retrieve all paths matching a value</li>
<li>replace    — substitute values inside nested lists</li>
<li>select     — extract subsets of elements</li>
<li>explode    — convert strings into lists of characters</li>
</ul>
<p>These allow lists to act as flexible containers for
hierarchical data.</p>
<h2 id="strings-1">Strings</h2>
<p>Strings in Rebel are sequences of characters enclosed in
double quotes.  They behave much like lists: most sequence
functions apply to both types without special cases.  This
keeps the language uniform and predictable.</p>
<p>A string literal is written as:</p>
<pre><code>"hello world"
</code></pre>
<p>Strings are immutable as values, but operations that update
a symbol holding a string are considered destructive—Rebel
replaces the stored value with a modified copy.</p>
<h3 id="string-as-a-sequence">String as a Sequence</h3>
<p>Many core sequence operations work on strings exactly as
they do on lists:</p>
<pre><code>(first "abc") ; -&#62; "a"
(rest  "abc") ; -&#62; "bc"
(length "abc") ; -&#62; 3
(nth 1 "xyz") ; -&#62; "y"
</code></pre>
<p>This uniformity means you can reason about strings and lists
using the same mental model.</p>
<h3 id="concatenation">Concatenation</h3>
<p>Strings can be joined using <code>append</code>:</p>
<pre><code>(append "ab" "cd") ; -&#62; "abcd"
</code></pre>
<p>Any number of arguments may be concatenated.</p>
<h3 id="slicing-and-substrings">Slicing and Substrings</h3>
<p>Use <code>slice</code> to extract parts of a string:</p>
<pre><code>(slice "abcdef" 1 3) ; -&#62; "bcd"
(slice "abcdef" 3)   ; -&#62; "def"
</code></pre>
<p>The function never modifies the original string.</p>
<h3 id="character-access-and-iteration">Character Access and Iteration</h3>
<p><code>nth</code> returns the character at a given position:</p>
<pre><code>(nth 2 "hello") ; -&#62; "l"
</code></pre>
<p>Characters themselves are strings of length one.</p>
<p>To traverse a string character by character:</p>
<pre><code>(dostring (ch "abc")
  (println ch))
</code></pre>
<h3 id="building-and-transforming-strings">Building and Transforming Strings</h3>
<p>Rebel includes several helpers:</p>
<ul>
<li><code>extend</code>   — append characters or another string</li>
<li><code>replace</code>  — substitute characters or substrings</li>
<li><code>reverse</code>  — reverse the order of characters</li>
<li><code>rotate</code>   — rotate characters by an offset</li>
<li><code>trim</code>     — remove whitespace</li>
<li><code>upper-case</code>, <code>lower-case</code>, <code>title-case</code> — character transformations</li>
<li><code>explode</code>  — split string into list of characters</li>
<li><code>join</code>     — join list of strings into one string</li>
</ul>
<p>Examples:</p>
<pre><code>(explode "abc") ; -&#62; ("a" "b" "c")
(join &#39;("a" "b" "c")) ; -&#62; "abc"
(reverse "abc") ; -&#62; "cba"
</code></pre>
<h3 id="parsing">Parsing</h3>
<p>Strings can be processed into tokens using <code>parse</code>:</p>
<pre><code>(parse "a,b,c" ",") ; -&#62; ("a" "b" "c")
</code></pre>
<p>Regular expressions are available with <code>regex</code> and
<code>regex-comp</code> for more advanced matching and extraction.</p>
<h3 id="destructive-string-updates">Destructive String Updates</h3>
<p>Some operations rewrite the value stored in a symbol:</p>
<pre><code>(set &#39;s "abc")
(push "x" s)  ; s becomes "xabc"
(pop s)       ; removes first character, returns "x"
</code></pre>
<p>These updates replace the string bound to <code>s</code>.  If other
symbols reference the same string, they will observe the
updated value as well.</p>
<h3 id="summary-4">Summary</h3>
<p>Strings in Rebel are:</p>
<ul>
<li>simple double-quoted sequences<br/></li>
<li>compatible with most list-oriented functions<br/></li>
<li>easy to slice, search, and transform<br/></li>
<li>capable of both destructive and non-destructive updates<br/></li>
<li>tightly integrated with sequence operations like append, first, rest, nth</li>
</ul>
<p>This gives strings a consistent role in the language without
requiring separate string-specific mechanisms.</p>
<h2 id="arrays">Arrays</h2>
<p>Arrays in Rebel are fixed-size, multi-dimensional sequences.
They provide structured, index-based storage similar to
lists, but with predictable layout and efficient element
access.  An array may have one or more dimensions, each with
a positive integer size.</p>
<p>Arrays are created with the <code>array</code> function:</p>
<pre><code>(array 3)       ; one-dimensional array of length 3
(array 2 2)     ; two-dimensional 2×2 array
(array 2 3 4)   ; three-dimensional array
</code></pre>
<p>Every array element is initialized to <code>nil</code> unless
explicitly set.</p>
<h3 id="accessing-elements-1">Accessing Elements</h3>
<p>Use <code>nth</code> to access elements by index.<br/>
Indexing is zero-based:</p>
<pre><code>(set &#39;a (array 2 2))
(nth 0 a)         ; -&#62; (nil nil)
(nth 1 a)         ; -&#62; (nil nil)
</code></pre>
<p>To reach nested elements, call <code>nth</code> repeatedly:</p>
<pre><code>(set &#39;m (array 2 2))
(setf (nth 0 m) &#39;(1 2))
(setf (nth 1 m) &#39;(3 4))
(nth 1 (nth 0 m)) ; -&#62; 2
</code></pre>
<h3 id="modifying-elements">Modifying Elements</h3>
<p>Arrays are mutable.<br/>
You can update an element using <code>setf</code> and <code>nth</code>:</p>
<pre><code>(set &#39;a (array 3))
(setf (nth 1 a) "x")
a  ; -&#62; (nil "x" nil)
</code></pre>
<p>For nested dimensions:</p>
<pre><code>(set &#39;m (array 2 2))
(setf (nth 1 (nth 0 m)) 42)
m ; -&#62; ((nil 42) (nil nil))
</code></pre>
<h3 id="array-size-and-shape">Array Size and Shape</h3>
<p>The size of an array is given by its dimensions.  Each
dimension has a fixed size specified at creation time.</p>
<pre><code>(length (array 4))     ; -&#62; 4
(length (array 2 3))   ; -&#62; 2
</code></pre>
<p>To inspect the full structure, convert to a list:</p>
<pre><code>(array-list (array 2 2)) ; -&#62; ((nil nil) (nil nil))
</code></pre>
<h3 id="conversion-between-arrays-and-lists">Conversion Between Arrays and Lists</h3>
<p><code>array-list</code> converts an array to a list representation:</p>
<pre><code>(set &#39;a (array 2 2))
(array-list a) ; -&#62; ((nil nil) (nil nil))
</code></pre>
<p>Lists can be inserted into arrays using <code>setf</code>:</p>
<pre><code>(set &#39;a (array 3))
(setf (nth 0 a) &#39;(x y z))
</code></pre>
<p>Be aware that improper shapes may cause errors if the
inserted value does not match the expected structure.</p>
<h3 id="multi-dimensional-usage">Multi-dimensional Usage</h3>
<p>Arrays support nested indexing naturally, allowing you to
model matrices, tables, grids, or multi-axis data layouts.</p>
<p>A simple 2×2 matrix:</p>
<pre><code>(set &#39;m (array 2 2))
(setf (nth 0 m) &#39;(1 2))
(setf (nth 1 m) &#39;(3 4))
m ; -&#62; ((1 2) (3 4))
</code></pre>
<p>You can implement matrix operations using built-ins like
<code>transpose</code>, <code>multiply</code>, <code>det</code>, and <code>invert</code>.</p>
<h3 id="destructive-vs-non-destructive">Destructive vs Non-destructive</h3>
<p>Most operations on arrays are destructive: the array
structure is updated in place when you use <code>setf</code>.
Non-destructive functions produce lists or new arrays,
leaving the original untouched.</p>
<p>Understanding this distinction is important when multiple
symbols reference the same array.</p>
<h3 id="summary-5">Summary</h3>
<p>Arrays provide:</p>
<ul>
<li>fixed-size, multi-dimensional structure<br/></li>
<li>efficient access by index<br/></li>
<li>compatibility with list-like operations via <code>array-list</code><br/></li>
<li>built-in numeric and matrix utilities<br/></li>
<li>clear destructive update semantics through <code>setf</code> and <code>nth</code></li>
</ul>
<p>They complement lists by offering predictable shape and efficient nested
indexing.</p>
<h2 id="functions-1">Functions</h2>
<p>Functions are central to Rebel.  They define reusable
computations, encapsulate logic, and allow code to be
structured into clear, composable units.  Functions in Rebel
are first-class values: they can be stored in variables,
passed as arguments, and returned from other functions.</p>
<p>A function call is simply a list whose first element
evaluates to a function, and the remaining elements are its
arguments:</p>
<pre><code>(+ 3 4)
</code></pre>
<p>This means that both built-in primitives and user-defined
procedures share the same calling syntax.</p>
<h3 id="defining-functions">Defining Functions</h3>
<p>A function is introduced with <code>define</code>:</p>
<pre><code>(define (square x)
  (* x x))
</code></pre>
<p>This creates a symbol named <code>square</code> bound to a lambda
expression.  Calling the function:</p>
<pre><code>(square 5) ; -&#62; 25
</code></pre>
<p>You can also use <code>lambda</code> directly:</p>
<pre><code>(set &#39;double (lambda (x) (* 2 x)))
(double 10) ; -&#62; 20
</code></pre>
<h3 id="parameters-and-arguments">Parameters and Arguments</h3>
<p>Function parameters are symbols that receive the evaluated
arguments.  Rebel performs normal argument evaluation before
calling the function, unless the form is a macro.</p>
<p>Multiple parameters:</p>
<pre><code>(define (add3 a b c)
  (+ a b c))

(add3 1 2 3) ; -&#62; 6
</code></pre>
<p>A function may also accept no arguments:</p>
<pre><code>(define (hello)
  "hi")
(hello) ; -&#62; "hi"
</code></pre>
<h3 id="local-variables-let-letn-letex-local">Local Variables: let, letn, letex, local</h3>
<p><code>let</code> introduces temporary bindings visible only within its
body:</p>
<pre><code>(let ((x 10) (y 20))
  (+ x y)) ; -&#62; 30
</code></pre>
<p><code>local</code> declares symbols as local within the current function:</p>
<pre><code>(define (demo)
  (local (a b))
  (set &#39;a 1)
  (set &#39;b 2)
  (+ a b))
</code></pre>
<p><code>letex</code> expands bindings directly into the expression before
evaluation, useful for building generated code.</p>
<p><code>letn</code> is similar to nested <code>let</code> blocks, allowing
sequential initialization.</p>
<h3 id="returning-values">Returning Values</h3>
<p>A function returns the value of its last expression.<br/>
There is no explicit <code>return</code> keyword:</p>
<pre><code>(define (max2 a b)
  (if (&#62; a b) a b))
</code></pre>
<p>Caller:</p>
<pre><code>(max2 7 5) ; -&#62; 7
</code></pre>
<h3 id="higher-order-functions">Higher-Order Functions</h3>
<p>Because functions are values, they can be passed to other
functions.</p>
<p>Example:</p>
<pre><code>(define (apply-twice f x)
  (f (f x)))

(apply-twice square 2) ; -&#62; 16
</code></pre>
<p>This enables powerful composition patterns without extra
syntax.</p>
<p>Rebel includes built-ins such as:</p>
<ul>
<li><code>map</code>       ; apply function to each element of a list<br/></li>
<li><code>filter</code>    ; keep only elements satisfying a predicate<br/></li>
<li><code>exists</code>    ; check if any element matches a condition<br/></li>
<li><code>for-all</code>   ; check if all elements match a condition</li>
</ul>
<h3 id="closures">Closures</h3>
<p>Functions capture the environment in which they are defined.
This mechanism is called a closure:</p>
<pre><code>(define (make-counter)
  (let ((x 0))
    (lambda ()
      (set &#39;x (+ x 1))
      x)))

(set &#39;c (make-counter))
(c) ; -&#62; 1
(c) ; -&#62; 2
</code></pre>
<p>The inner lambda remembers the value of <code>x</code> even after
<code>make-counter</code> finishes.</p>
<h3 id="anonymous-functions">Anonymous Functions</h3>
<p>Any <code>lambda</code> expression can be used inline without naming
it:</p>
<pre><code>((lambda (x y) (+ x y)) 3 4) ; -&#62; 7
</code></pre>
<p>Anonymous functions are common in mapping, filtering, or
callback-style code.</p>
<h3 id="curry">curry</h3>
<p><code>curry</code> transforms a function of two arguments into a
function of one argument with the first value fixed:</p>
<pre><code>(define add3 (curry + 3))
(add3 10) ; -&#62; 13
</code></pre>
<p>This is convenient for building specialized operations from
general-purpose ones.</p>
<h3 id="apply">apply</h3>
<p><code>apply</code> calls a function using a list of arguments.<br/>
Useful when arguments are constructed dynamically:</p>
<pre><code>(apply + &#39;(1 2 3 4)) ; -&#62; 10
</code></pre>
<p>You can apply both primitive functions and user-defined
lambdas.</p>
<h3 id="function-introspection">Function Introspection</h3>
<p>Functions are data, so their structure can be inspected:</p>
<pre><code>(args square) ; returns parameter list
(source square) ; returns code needed to reproduce it
</code></pre>
<p>This is part of Rebel’s reflective capabilities.</p>
<h3 id="summary-6">Summary</h3>
<p>Functions in Rebel are:</p>
<ul>
<li>first-class values<br/></li>
<li>defined with <code>define</code> or <code>lambda</code><br/></li>
<li>called with uniform s-expression syntax<br/></li>
<li>capable of capturing local environments (closures)<br/></li>
<li>composable through higher-order patterns<br/></li>
<li>fully introspectable using built-in tools</li>
</ul>
<p>This minimal and consistent model enables concise,
expressive programs with few syntactic rules.</p>
<h2 id="evaluation-model">Evaluation Model</h2>
<p>Rebel uses a simple and uniform evaluation model based on
classic Lisp semantics.  Every expression is an
s-expression, and the rules that determine how an expression
is evaluated are consistent across the entire language.</p>
<p>Understanding these rules is essential, because the behavior
of the whole language — functions, macros, flow control,
closures, contexts — follows directly from them.</p>
<h3 id="what-an-expression-is">What an Expression Is</h3>
<p>An expression is either:</p>
<ul>
<li>an atom (number, string, symbol, nil, true)</li>
<li>a list: (operator arg-1 arg-2 &#8230;)</li>
</ul>
<p>Atoms evaluate to themselves, except symbols, which evaluate
to the value they are bound to.</p>
<p>Lists follow the function call pattern:</p>
<ol>
<li>evaluate the first element<br/></li>
<li>evaluate all arguments<br/></li>
<li>call the resulting function with those arguments</li>
</ol>
<h3 id="symbol-evaluation">Symbol Evaluation</h3>
<p>A symbol evaluates to whatever value it holds:</p>
<pre><code>(set &#39;x 10)
x         ; -&#62; 10
</code></pre>
<p>If a symbol has no value, an error is raised.</p>
<p>Quoted symbols do not evaluate:</p>
<pre><code>&#39;x         ; -&#62; x
</code></pre>
<h3 id="quoting-and-literal-data">Quoting and Literal Data</h3>
<p>Quoting suppresses evaluation entirely.  This is how literal
lists and expressions are written:</p>
<pre><code>&#39;(+ 1 2) ; -&#62; (+ 1 2)
</code></pre>
<p>Without quote, the same expression would be treated as a
function call.</p>
<p>The full form:</p>
<pre><code>(quote (+ 1 2))
</code></pre>
<h3 id="list-evaluation">List Evaluation</h3>
<p>A list is treated as a function call unless quoted.</p>
<pre><code>(+ 3 4)
</code></pre>
<p>The evaluation process:</p>
<ul>
<li><code>+</code> is evaluated → the built-in addition function</li>
<li>arguments 3 and 4 evaluate to themselves</li>
<li>the function is called with arguments → 7</li>
</ul>
<h3 id="special-forms">Special Forms</h3>
<p>Some symbols evaluate differently and control evaluation of
their arguments.  These include:</p>
<ul>
<li><code>if</code></li>
<li><code>cond</code></li>
<li><code>define</code></li>
<li><code>lambda</code></li>
<li><code>begin</code></li>
<li><code>let</code>, <code>letex</code>, <code>letn</code></li>
<li><code>quote</code></li>
</ul>
<p>Special forms decide which subexpressions are evaluated and
which are not.  For example, <code>if</code> evaluates only the
selected branch:</p>
<pre><code>(if true 1 (&#47; 1 0)) ; -&#62; 1  ; division never happens
</code></pre>
<h3 id="macros-and-reader-level-expansion">Macros and Reader-Level Expansion</h3>
<p>Macros operate on the <em>unevaluated</em> structure of
expressions.  A macro receives raw lists and symbols and
returns a transformed expression that is later evaluated
normally.</p>
<pre><code>(define-macro (inc! x)
  (list &#39;set x (list &#39;+ x 1)))

(set &#39;n 5)
(inc! n)  ; expands to (set &#39;n (+ n 1))
n         ; -&#62; 6
</code></pre>
<p>This mechanism allows the language to be extended without
changing the interpreter.</p>
<h3 id="eval">Eval</h3>
<p><code>eval</code> takes any expression and evaluates it according to
the same rules used for ordinary code:</p>
<pre><code>(set &#39;e &#39;(+ 1 2))
(eval e) ; -&#62; 3
</code></pre>
<p>Because code is represented as lists, it can be constructed,
transformed, and executed at runtime.</p>
<h3 id="building-expressions-programmatically">Building Expressions Programmatically</h3>
<p>Expressions can be created by assembling lists:</p>
<pre><code>(set &#39;x 10)
(set &#39;expr (list &#39;+ x 5))
(eval expr) ; -&#62; 15
</code></pre>
<p>This unifies data transformation and code generation.</p>
<h3 id="function-evaluation-and-closures">Function Evaluation and Closures</h3>
<p>Functions evaluate their bodies in the environment where
they were defined.</p>
<pre><code>(define (make-adder n)
  (lambda (x) (+ x n)))

(set &#39;add5 (make-adder 5))
(add5 10) ; -&#62; 15
</code></pre>
<p>The inner lambda keeps access to <code>n</code> even after <code>make-adder</code>
returns.  This is the closure mechanism and it is part of
the evaluation model.</p>
<h3 id="error-propagation">Error Propagation</h3>
<p>Errors during evaluation are thrown upward until:</p>
<ul>
<li>a <code>catch</code> form intercepts them, or</li>
<li>evaluation reaches the top level, where they are printed</li>
</ul>
<pre><code>(catch
  (&#47; 1 0)
  "division error")
</code></pre>
<p>The return value is the value of the handler expression.</p>
<h3 id="summary-7">Summary</h3>
<p>Rebel’s evaluation model is:</p>
<ul>
<li>simple and uniform<br/></li>
<li>based entirely on s-expression structure<br/></li>
<li>predictable due to explicit evaluation rules<br/></li>
<li>flexible because code and data share one representation<br/></li>
<li>extensible through macros and programmatic construction<br/></li>
<li>expressive through closures and higher-order functions</li>
</ul>
<p>This model is the foundation of the entire language and remains consistent
across all constructs.</p>
<h2 id="contexts">Contexts</h2>
<p>Contexts in Rebel are lightweight namespaces.  They group
related symbols together and prevent name collisions between
different parts of a program.  A context acts as a container
for symbols, functions, and even subcontexts.</p>
<p>Contexts behave like associative tables: each symbol inside
a context has its own binding independent from symbols
elsewhere.  This provides isolation without complexity.</p>
<h3 id="creating-and-switching-contexts">Creating and Switching Contexts</h3>
<p>A context is created implicitly when referenced, or
explicitly with <code>context</code>:</p>
<pre><code>(context &#39;Math)
</code></pre>
<p>Switching into a context makes it the default namespace for
symbol creation:</p>
<pre><code>(context &#39;Math)
(set &#39;pi 3.14159)
</code></pre>
<p>Here, the symbol <code>pi</code> belongs to the <code>Math</code> context.</p>
<h3 id="accessing-symbols-in-a-context">Accessing Symbols in a Context</h3>
<p>To refer to a symbol inside a context without switching, use
prefix notation:</p>
<pre><code>Math:pi
</code></pre>
<p>This reads “symbol <code>pi</code> inside context <code>Math</code>”.</p>
<p>You can also assign this way:</p>
<pre><code>(set &#39;Math:e 2.71828)
</code></pre>
<p>Now the context contains two symbols: <code>pi</code> and <code>e</code>.</p>
<h3 id="nested-contexts">Nested Contexts</h3>
<p>Contexts may contain other contexts:</p>
<pre><code>(context &#39;Geometry)
(set &#39;Geometry:circle (context &#39;Geometry:circle))
</code></pre>
<p>Subcontexts follow the same rules:</p>
<pre><code>(set &#39;Geometry:circle:radius 10)
</code></pre>
<h3 id="defining-functions-in-contexts">Defining Functions in Contexts</h3>
<p>Functions can also be namespaced:</p>
<pre><code>(context &#39;Tools)

(define (Tools:add2 x)
  (+ x 2))

(Tools:add2 10) ; -&#62; 12
</code></pre>
<p>Switching into a context automatically defines symbols
inside it:</p>
<pre><code>(context &#39;Tools)
(define (mul2 x) (* x 2))

(Tools:mul2 5) ; -&#62; 10
</code></pre>
<h3 id="copying-and-exporting-symbols">Copying and Exporting Symbols</h3>
<p><code>def-new</code> copies a symbol from one context to another:</p>
<pre><code>(context &#39;A)
(set &#39;A:value 10)

(context &#39;B)
(def-new &#39;B:value &#39;A:value)
B:value ; -&#62; 10
</code></pre>
<p>This is useful when building modules or exposing parts of a
library.</p>
<h3 id="retrieving-symbol-lists">Retrieving Symbol Lists</h3>
<p>You can list all symbols inside a context using <code>symbols</code>:</p>
<pre><code>(context &#39;Net)
(set &#39;Net:port 80)
(set &#39;Net:host "localhost")

(symbols &#39;Net)
; -&#62; (Net:port Net:host)
</code></pre>
<h3 id="using-contexts-as-modules">Using Contexts as Modules</h3>
<p>Contexts naturally serve as modules.<br/>
A typical pattern:</p>
<pre><code>(context &#39;Math)

(define (Math:sum lst)
  (apply + lst))

(define (Math:avg lst)
  (&#47; (Math:sum lst) (length lst)))

(Math:avg &#39;(10 20 30)) ; -&#62; 20
</code></pre>
<p>This makes dependencies explicit and prevents accidental
name shadowing.</p>
<h3 id="default-context-main">Default Context: MAIN</h3>
<p>Every program starts in the context <code>MAIN</code>, which holds all
global symbols not assigned elsewhere.  Switching contexts
does not erase MAIN; it remains accessible:</p>
<pre><code>MAIN:x
</code></pre>
<p>If the name exists in the current context, that binding
takes precedence.</p>
<h3 id="context-prefixing">Context Prefixing</h3>
<p><code>prefix</code> returns the full context-qualified name of a
symbol:</p>
<pre><code>(prefix &#39;Math:pi) ; -&#62; "Math:pi"
</code></pre>
<p>This is helpful for building tools and implementing
introspection.</p>
<h3 id="summary-8">Summary</h3>
<p>Contexts in Rebel provide:</p>
<ul>
<li>lightweight namespaces<br/></li>
<li>clear separation of symbols<br/></li>
<li>safe modular organization<br/></li>
<li>nested namespace hierarchies<br/></li>
<li>simple prefix-based access<br/></li>
<li>integration with define, lambda, and all built-ins</li>
</ul>
<p>They avoid the complexity of heavy module systems while
preserving clarity in large programs.</p>
<h2 id="foop-functional-object-orientation">FOOP (Functional Object Orientation)</h2>
<p>FOOP is Rebel’s minimal object system built entirely from
contexts and functions.  There are no classes, inheritance
chains, or special syntax—FOOP uses the existing evaluation
model and namespaces to provide object-like behavior.</p>
<p>A FOOP object is simply a context that contains:</p>
<ul>
<li>data fields (symbols holding values)</li>
<li>methods (functions whose first symbol is <code>self</code>)</li>
<li>optional nested objects or subcontexts</li>
</ul>
<p>This approach keeps the implementation small while allowing
structured, encapsulated data.</p>
<h3 id="creating-an-object">Creating an Object</h3>
<p>An object is just a context:</p>
<pre><code>(context &#39;Point)
</code></pre>
<p>Assign fields directly into it:</p>
<pre><code>(set &#39;Point:x 0)
(set &#39;Point:y 0)
</code></pre>
<p>Methods are functions stored inside the context:</p>
<pre><code>(define (Point:move dx dy)
  (set &#39;Point:x (+ Point:x dx))
  (set &#39;Point:y (+ Point:y dy)))
</code></pre>
<h3 id="self">self</h3>
<p>Inside a FOOP method, <code>self</code> is bound to the target object.
It allows methods to refer to the context they belong to,
even if the method is invoked via another symbol.</p>
<p>Example of a method using <code>self</code>:</p>
<pre><code>(define (Point:reset)
  (set &#39;self:x 0)
  (set &#39;self:y 0))
</code></pre>
<p><code>self:x</code> means “the symbol <code>x</code> inside the current object
context”.</p>
<h3 id="creating-multiple-instances">Creating Multiple Instances</h3>
<p>To make multiple instances, copy an existing context:</p>
<pre><code>(set &#39;A (new Point))
(set &#39;B (new Point))
</code></pre>
<p>Each instance has its own fields and methods.<br/>
Updating one does not modify the other:</p>
<pre><code>(set &#39;A:x 10)
(Point:x) ; -&#62; 0
A:x       ; -&#62; 10
B:x       ; -&#62; 0
</code></pre>
<h3 id="methods-and-message-passing">Methods and Message Passing</h3>
<p>Calling a method is simply calling a namespaced function:</p>
<pre><code>(Point:move 3 4)
(Point:x) ; -&#62; 3
(Point:y) ; -&#62; 4
</code></pre>
<p>Instances behave the same way:</p>
<pre><code>(A:move 2 2)
(A:x) ; -&#62; 12
(A:y) ; -&#62; 2
</code></pre>
<p>The FOOP system works because the first symbol of a function
name determines the context, and thus the object.</p>
<h3 id="encapsulation-through-namespacing">Encapsulation Through Namespacing</h3>
<p>All fields and methods of an object live inside its context.
Nothing is special-cased—the value of <code>A:x</code> is a normal
symbol, not a hidden slot or member variable.</p>
<p>This means encapsulation is maintained by discipline and
naming, not by restrictions in the language.</p>
<h3 id="initializers-and-constructors">Initializers and Constructors</h3>
<p>You can simulate constructors by defining a function that
builds and returns a new object context:</p>
<pre><code>(define (make-point x y)
  (let ((obj (new Point)))
    (set &#39;obj:x x)
    (set &#39;obj:y y)
    obj))

(set &#39;P (make-point 5 7))
(P:x) ; -&#62; 5
(P:y) ; -&#62; 7
</code></pre>
<p>This pattern is simple and powerful.</p>
<h3 id="methods-operating-on-nested-objects">Methods Operating on Nested Objects</h3>
<p>Because contexts may contain subcontexts, FOOP naturally
represents hierarchical objects:</p>
<pre><code>(context &#39;Rect)
(set &#39;Rect:pos (new Point))
(set &#39;Rect:size &#39;(10 20))

(define (Rect:move dx dy)
  (Rect:pos:move dx dy))
</code></pre>
<p>Objects can delegate functionality to their subcomponents.</p>
<h3 id="polymorphism-by-context-replacement">Polymorphism by Context Replacement</h3>
<p>Rebel does not enforce static types.  If two contexts
implement the same method names, they can be used
interchangeably:</p>
<pre><code>(context &#39;Dog)
(define (Dog:speak) "woof")

(context &#39;Cat)
(define (Cat:speak) "meow")

(map (lambda (obj) (obj:speak)) (list (new Dog) (new Cat)))
; -&#62; ("woof" "meow")
</code></pre>
<p>This is functional polymorphism through namespacing.</p>
<h3 id="summary-9">Summary</h3>
<p>FOOP provides:</p>
<ul>
<li>object-like structures built from contexts<br/></li>
<li>per-object fields and methods<br/></li>
<li>dynamic dispatch based on context prefix<br/></li>
<li>closures and functions as core implementation<br/></li>
<li>easy creation of multiple instances<br/></li>
<li>simple polymorphism through shared method names<br/></li>
</ul>
<p>It avoids the complexity of traditional OO systems while
giving Rebel a practical way to organize data and behavior.</p>
<h2 id="sequences">Sequences</h2>
<p>Sequences in Rebel are a unified concept that covers
<strong>lists</strong>, <strong>strings</strong>, and <strong>arrays</strong>.  They all share a
common set of operations—indexing, slicing, appending,
searching, transformation—so that you can work with them
using the same mental model.</p>
<p>This uniformity is one of Rebel’s strongest features.  Most
sequence functions do not care what specific type they
operate on.</p>
<h3 id="a-unified-model">A Unified Model</h3>
<p>A sequence is any ordered collection of elements accessible by index:</p>
<ul>
<li>lists: variable-length, heterogeneous</li>
<li>strings: immutable sequences of characters</li>
<li>arrays: fixed-size, multi-dimensional blocks</li>
</ul>
<p>Even though these structures differ internally, sequence
operations apply to all of them consistently.</p>
<h3 id="basic-access">Basic Access</h3>
<p>Common operations across all sequences:</p>
<pre><code>(first &#39;(a b c))  ; -&#62; a
(first "abc")     ; -&#62; "a"
(first (array 3)) ; -&#62; nil
</code></pre>
<pre><code>(rest &#39;(a b c))   ; -&#62; (b c)
(rest "abc")      ; -&#62; "bc"
</code></pre>
<pre><code>(nth 1 &#39;(x y z))  ; -&#62; y
(nth 2 "hello")   ; -&#62; "l"
</code></pre>
<p><code>length</code> returns the number of top-level elements:</p>
<pre><code>(length &#39;(1 2 3))  ; -&#62; 3
(length "abc")     ; -&#62; 3
(length (array 4)) ; -&#62; 4
</code></pre>
<h3 id="building-and-combining-sequences">Building and Combining Sequences</h3>
<p>Sequences can be extended or combined:</p>
<pre><code>(append &#39;(1 2) &#39;(3 4)) ; -&#62; (1 2 3 4)
(append "ab" "cd")     ; -&#62; "abcd"
</code></pre>
<p><code>extend</code> appends to an existing sequence (destructive when
applied to a symbol):</p>
<pre><code>(set &#39;s "ab")
(extend s "c")
s ; -&#62; "abc"
</code></pre>
<h3 id="slicing">Slicing</h3>
<p><code>slice</code> extracts a contiguous portion:</p>
<pre><code>(slice &#39;(1 2 3 4) 1 2) ; -&#62; (2 3)
(slice "abcdef" 2 3)   ; -&#62; "cde"
</code></pre>
<p>When the start index is omitted:</p>
<pre><code>(slice "abcdef" 3) ; -&#62; "def"
</code></pre>
<h3 id="transformations">Transformations</h3>
<p>Common transformations work on all sequence types:</p>
<ul>
<li><code>reverse</code><br/></li>
<li><code>rotate</code><br/></li>
<li><code>flat</code><br/></li>
<li><code>unique</code><br/></li>
</ul>
<p>Examples:</p>
<pre><code>(reverse &#39;(a b c)) ; -&#62; (c b a)
(reverse "abc")    ; -&#62; "cba"
</code></pre>
<h3 id="searching">Searching</h3>
<p>Rebel provides a set of search functions:</p>
<pre><code>(find 3 &#39;(1 2 3 4)) ; -&#62; 2
(find "b" "abc")    ; -&#62; 1
</code></pre>
<p>Prefix and suffix tests:</p>
<pre><code>(starts-with &#39;(a b c) &#39;(a)) ; -&#62; true
(ends-with "hello" "lo")    ; -&#62; true
</code></pre>
<p><code>member</code> checks for membership:</p>
<pre><code>(member &#39;b &#39;(a b c)) ; -&#62; true
</code></pre>
<h3 id="filtering-and-selection">Filtering and Selection</h3>
<p><code>filter</code> keeps elements that satisfy a predicate:</p>
<pre><code>(filter (lambda (x) (&#62; x 2)) &#39;(1 2 3 4)) ; -&#62; (3 4)
</code></pre>
<p><code>select</code> can reorder or extract specific indices:</p>
<pre><code>(select &#39;(2 0) &#39;(a b c)) ; -&#62; (c a)
</code></pre>
<h3 id="conversion-between-types">Conversion Between Types</h3>
<p>Convert a string to a list of characters:</p>
<pre><code>(explode "abc") ; -&#62; ("a" "b" "c")
</code></pre>
<p>Join strings together:</p>
<pre><code>(join &#39;("x" "y" "z")) ; -&#62; "xyz"
</code></pre>
<p>Convert arrays to lists:</p>
<pre><code>(array-list (array 2 2)) ; -&#62; ((nil nil) (nil nil))
</code></pre>
<h3 id="nested-sequences">Nested Sequences</h3>
<p>Sequences can be nested into trees:</p>
<pre><code>(set &#39;t &#39;(a (b (c d)) e))
</code></pre>
<p>Retrieve values using paths:</p>
<pre><code>(ref t &#39;(1 1)) ; -&#62; c
(ref-all t &#39;c) ; -&#62; ((1 1))
</code></pre>
<p>Modify nested structures:</p>
<pre><code>(replace t &#39;c &#39;X) ; -&#62; (a (b (X d)) e)
</code></pre>
<h3 id="destructive-vs-non-destructive-1">Destructive vs Non-destructive</h3>
<p>Some sequence functions update an existing structure:</p>
<ul>
<li>push</li>
<li>pop</li>
<li>extend</li>
<li>replace</li>
<li>swap</li>
</ul>
<p>Others produce new sequences:</p>
<ul>
<li>append</li>
<li>slice</li>
<li>reverse</li>
<li>unique</li>
<li>flat</li>
</ul>
<p>This is important when multiple symbols reference the same sequence.</p>
<h3 id="summary-10">Summary</h3>
<p>Sequences provide:</p>
<ul>
<li>a unified interface across lists, strings, and arrays<br/></li>
<li>consistent access (first, rest, nth)<br/></li>
<li>structural manipulation (append, slice, extend, replace)<br/></li>
<li>searching and filtering (find, filter, member)<br/></li>
<li>type conversion utilities (explode, join, array-list)<br/></li>
<li>nested sequence traversal (ref, ref-all)<br/></li>
<li>destructive and non-destructive modes depending on the function</li>
</ul>
<p>This unified model simplifies reasoning and makes Rebel’s
core data structures behave coherently across different
contexts.</p>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>Pattern matching in Rebel provides a declarative way to
inspect, compare, and extract structure from lists, strings,
and nested sequences.  Unlike conditional chains or manual
traversal, pattern matching expresses the shape of data
directly and lets the matcher verify or decompose it.</p>
<p>Rebel includes several pattern-oriented functions:</p>
<ul>
<li>match</li>
<li>find &#47; find-all</li>
<li>starts-with &#47; ends-with</li>
<li>ref &#47; ref-all</li>
<li>replace</li>
<li>unify</li>
</ul>
<p>These tools cover both structural list matching and string
pattern searches.</p>
<h3 id="structural-matching-with-match">Structural Matching with match</h3>
<p><code>match</code> compares a pattern against a list or nested list
structure.  A pattern may include literals, symbols,
wildcards, and nested forms.</p>
<p>Basic example:</p>
<pre><code>(match &#39;(a b c) &#39;(a b c)) ; -&#62; true
</code></pre>
<p>Patterns may contain symbols which bind to matched values:</p>
<pre><code>(match &#39;(a x c) &#39;(a b c)) ; x becomes b  -&#62; true
</code></pre>
<p>Wildcard <code>_</code> matches any value without binding:</p>
<pre><code>(match &#39;(a _ c) &#39;(a 99 c)) ; -&#62; true
</code></pre>
<h3 id="nested-patterns">Nested Patterns</h3>
<p>Patterns can describe nested structures:</p>
<pre><code>(match &#39;(a (b x) y) &#39;(a (b 10) 20)) ; x -&#62; 10, y -&#62; 20
</code></pre>
<p>If the structure differs, the match fails:</p>
<pre><code>(match &#39;(a (b x)) &#39;(a (c 5))) ; -&#62; nil
</code></pre>
<h3 id="binding-and-side-effects">Binding and Side Effects</h3>
<p>When a pattern uses ordinary symbols, they become bound to
the matching values:</p>
<pre><code>(match &#39;(x y) &#39;(1 2))
x ; -&#62; 1
y ; -&#62; 2
</code></pre>
<p>Only symbols appearing in the pattern are affected.</p>
<h3 id="string-pattern-matching">String Pattern Matching</h3>
<p>Strings use a different mechanism centered on search
functions.</p>
<p><code>find</code> locates a substring:</p>
<pre><code>(find "b" "abc") ; -&#62; 1
(find "x" "abc") ; -&#62; nil
</code></pre>
<p><code>find-all</code> returns all matching positions:</p>
<pre><code>(find-all "l" "hello") ; -&#62; (2 3)
</code></pre>
<p>These functions operate by literal substring comparison, not
structural patterns.</p>
<h3 id="prefix-and-suffix-testing">Prefix and Suffix Testing</h3>
<p>Two simple helpers check boundaries:</p>
<pre><code>(starts-with "hello" "he") ; -&#62; true
(ends-with   "hello" "lo") ; -&#62; true
</code></pre>
<p>These work on both strings and lists.</p>
<h3 id="ref-and-ref-all-for-nested-access">ref and ref-all for Nested Access</h3>
<p><code>ref</code> retrieves the element at a given path in a nested
structure:</p>
<pre><code>(ref &#39;(a (b (c d))) &#39;(1 1)) ; -&#62; c
</code></pre>
<p><code>ref-all</code> returns all paths matching a given value:</p>
<pre><code>(ref-all &#39;(a (b (c a))) &#39;a)
; -&#62; ((0) (1 1 1))
</code></pre>
<h3 id="replace-for-pattern-substitution">replace for Pattern Substitution</h3>
<p><code>replace</code> rewrites values inside lists or strings.<br/>
For lists:</p>
<pre><code>(replace &#39;(a b a) &#39;a &#39;x) ; -&#62; (x b x)
</code></pre>
<p>For strings:</p>
<pre><code>(replace "banana" "a" "x") ; -&#62; "bxnxnx"
</code></pre>
<h3 id="unify-for-logical-matching">unify for Logical Matching</h3>
<p><code>unify</code> tests whether two expressions can be made identical
by assigning values to variables (symbols).  It is a more
general and logical version of <code>match</code>.</p>
<pre><code>(unify &#39;(a x b) &#39;(a 10 b)) ; x -&#62; 10, returns true
(unify &#39;(a x b) &#39;(a y b))  ; assigns x=y, returns true
</code></pre>
<p>If there is a contradiction, unification fails:</p>
<pre><code>(unify &#39;(x x) &#39;(1 2)) ; -&#62; nil
</code></pre>
<h3 id="when-to-use-what">When to Use What</h3>
<ul>
<li><strong>match</strong>: structural list matching with binding<br/></li>
<li><strong>find &#47; find-all</strong>: substring search<br/></li>
<li><strong>starts-with &#47; ends-with</strong>: boundary tests<br/></li>
<li><strong>ref &#47; ref-all</strong>: navigate nested structures<br/></li>
<li><strong>replace</strong>: pattern substitution in lists or strings<br/></li>
<li><strong>unify</strong>: logical equivalence with variable binding</li>
</ul>
<h3 id="summary-11">Summary</h3>
<p>Pattern matching in Rebel enables:</p>
<ul>
<li>declarative structural checks<br/></li>
<li>nested pattern decomposition<br/></li>
<li>flexible variable binding<br/></li>
<li>logical unification<br/></li>
<li>sequence search and replacement tools<br/></li>
<li>uniform syntax across lists and strings</li>
</ul>
<p>This makes it easy to express data-shaped logic without
manual traversal or complex conditional code.</p>
<h2 id="io-input-and-output">I&#47;O (Input and Output)</h2>
<p>Rebel provides simple but powerful tools for reading and
writing data.  These functions cover file I&#47;O, console
interaction, and binary operations.  The API is small,
uniform, and mirrors classic Unix streams.</p>
<p>Input&#47;output in Rebel is synchronous and blocking: the
interpreter reads or writes data directly, without buffering
abstractions or async layers.  This keeps behavior
predictable and minimal.</p>
<h3 id="opening-and-closing-files">Opening and Closing Files</h3>
<p>Files are opened using <code>open</code>, which returns a file handle:</p>
<pre><code>(set &#39;f (open "data.txt" "read"))
</code></pre>
<p>Modes include:</p>
<ul>
<li><code>"read"</code></li>
<li><code>"write"</code></li>
<li><code>"append"</code></li>
<li><code>"read-write"</code></li>
</ul>
<p>Always close a file when done:</p>
<pre><code>(close f)
</code></pre>
<h3 id="reading-lines-and-characters">Reading Lines and Characters</h3>
<p><code>read-line</code> reads a line from a file or standard input:</p>
<pre><code>(set &#39;f (open "data.txt" "read"))
(read-line f)
</code></pre>
<p>Reading characters:</p>
<pre><code>(read-char f)
</code></pre>
<p>Reading UTF-8 characters:</p>
<pre><code>(read-utf8 f)
</code></pre>
<p>Binary reads:</p>
<pre><code>(read f 8)   ; read 8 bytes
</code></pre>
<h3 id="writing-output">Writing Output</h3>
<p>Writing to the console:</p>
<pre><code>(print "hello")
(println "world")
</code></pre>
<p>Writing to a file:</p>
<pre><code>(set &#39;f (open "out.txt" "write"))
(write-line f "hello")
(write f "raw-bytes")
(close f)
</code></pre>
<p><code>device</code> changes the default output target.</p>
<h3 id="whole-file-operations">Whole-File Operations</h3>
<p>To read or write an entire file at once:</p>
<pre><code>(read-file "data.txt")
</code></pre>
<pre><code>(write-file "out.txt" "contents")
</code></pre>
<p><code>append-file</code> appends to an existing file:</p>
<pre><code>(append-file "log.txt" "entry\n")
</code></pre>
<h3 id="peek">peek</h3>
<p><code>peek</code> returns the number of pending bytes available on a
file descriptor without blocking:</p>
<pre><code>(peek f) ; -&#62; number of bytes ready
</code></pre>
<p>Useful for interactive streams and piped input.</p>
<h3 id="keyboard-input">Keyboard Input</h3>
<p>Reading a single key from the keyboard:</p>
<pre><code>(read-key)
</code></pre>
<p>This does not wait for a newline, unlike read-line.</p>
<h3 id="pipes-and-external-processes">Pipes and External Processes</h3>
<p>You can execute external commands using <code>exec</code>:</p>
<pre><code>(set &#39;p (exec "ls -l"))
(read-line p)
(close p)
</code></pre>
<p><code>exec</code> opens a bidirectional pipe: you can both send to and
read from the process.</p>
<h3 id="saving-data-structures">Saving Data Structures</h3>
<p>Objects and contexts can be stored using <code>save</code>:</p>
<pre><code>(save &#39;MyData "backup.lsp")
</code></pre>
<p>This writes an s-expression representation, not a binary
format.</p>
<h3 id="searching-inside-files">Searching Inside Files</h3>
<p><code>search</code> scans a file for a substring:</p>
<pre><code>(search "notes.txt" "keyword")
</code></pre>
<p>Returns the index of the first match or nil.</p>
<h3 id="seek">seek</h3>
<p>Use <code>seek</code> to reposition the file cursor:</p>
<pre><code>(set &#39;f (open "big.bin" "read"))
(seek f 1000)
(read f 16) ; read 16 bytes starting from offset 1000
</code></pre>
<h3 id="summary-12">Summary</h3>
<p>Rebel’s I&#47;O system provides:</p>
<ul>
<li>straightforward file open&#47;close semantics<br/></li>
<li>line, character, UTF-8, and binary reads<br/></li>
<li>simple writing primitives<br/></li>
<li>whole-file utilities for quick operations<br/></li>
<li>external process execution via pipes<br/></li>
<li>interactive keyboard input<br/></li>
<li>stream introspection with peek<br/></li>
<li>file searching and cursor control<br/></li>
</ul>
<p>The model stays minimal and close to classic Unix behavior,
giving precise and predictable control over I&#47;O.</p>
<h2 id="processes">Processes</h2>
<p>Rebel provides a small set of primitives for creating and
communicating with external processes.  The model is
synchronous and direct, offering simple access to classic
Unix process behavior: pipes, child processes, message
passing, and cleanup.</p>
<p>Rebel does not hide system-level concepts.  A process is a
real OS process, and communication uses actual file
descriptors or sockets.</p>
<h3 id="running-external-commands-exec">Running External Commands: exec</h3>
<p><code>exec</code> starts a child process and opens a bidirectional pipe
connected to it.  You can read output from the process or
write input to it.</p>
<pre><code>(set &#39;p (exec "ls -l"))
(read-line p)   ; read one line from the command
(close p)
</code></pre>
<p>Anything written to the process goes to its stdin:</p>
<pre><code>(set &#39;p (exec "cat"))
(write p "hello\n")
(read-line p)  ; -&#62; "hello"
(close p)
</code></pre>
<h3 id="unidirectional-pipes-pipe">Unidirectional Pipes: pipe</h3>
<p><code>pipe</code> creates a raw pipe pair:</p>
<pre><code>(set &#39;p (pipe))
(write (p 1) "hello")
(read (p 0) 5) ; -&#62; "hello"
</code></pre>
<p><code>p</code> is a two-element list:<br/>
- <code>(p 0)</code> is the read end<br/>
- <code>(p 1)</code> is the write end</p>
<p>Useful for custom IPC setups.</p>
<h3 id="creating-a-new-interpreter-process">Creating a New Interpreter: process</h3>
<p><code>process</code> launches a new Rebel interpreter as a child.
Input and output can be redirected:</p>
<pre><code>(set &#39;c (process "rebel"))
(write-line c "(+ 2 3)")
(read-line c) ; -&#62; "5"
(close c)
</code></pre>
<p>This allows embedding a separate evaluator or worker
process.</p>
<h3 id="lightweight-parallelism-spawn-and-sync">Lightweight Parallelism: spawn and sync</h3>
<p><code>spawn</code> creates a child process to evaluate an expression
asynchronously.  The parent continues immediately.</p>
<pre><code>(set &#39;job (spawn (begin (sleep 500) 42)))
</code></pre>
<p><code>sync</code> waits for all spawned processes and returns their
results:</p>
<pre><code>(sync) ; -&#62; (42)
</code></pre>
<p>This gives Rebel a simple form of parallel execution using
OS processes.</p>
<h3 id="terminating-processes-abort">Terminating Processes: abort</h3>
<p><code>abort</code> stops a process created with <code>spawn</code>:</p>
<pre><code>(set &#39;job (spawn (sleep 9999)))
(abort job)
</code></pre>
<p>The aborted job will not appear in <code>sync</code> results.</p>
<h3 id="child-process-control-wait-pid">Child Process Control: wait-pid</h3>
<p><code>wait-pid</code> allows explicit waiting on a child:</p>
<pre><code>(wait-pid job)
</code></pre>
<p>It is useful when managing external processes launched via
<code>fork</code> or system tools rather than Rebel primitives.</p>
<h3 id="message-passing-send-and-receive">Message Passing: send and receive</h3>
<p>Rebel includes message-based IPC between processes:</p>
<pre><code>(spawn (receive) (println "child got:" (receive)))
(send (sys-info 4) "hello")
</code></pre>
<p><code>send</code> sends a message to a process.  <code>receive</code> retrieves
the next message delivered to the current process.</p>
<p>This mechanism is simple but effective for building parallel
workers.</p>
<h3 id="shared-memory-share">Shared Memory: share</h3>
<p><code>share</code> exposes a memory region to multiple processes.  It
behaves like a global variable accessible across process
boundaries.</p>
<pre><code>(share &#39;counter 0)
(spawn (set &#39;counter (+ counter 1)))
(spawn (set &#39;counter (+ counter 1)))
(sleep 50)
counter ; -&#62; 2
</code></pre>
<p>Used carefully, it enables fast communication and state
passing.</p>
<h3 id="destroying-processes-destroy">Destroying Processes: destroy</h3>
<p><code>destroy</code> terminates a process created with <code>fork</code> or <code>process</code>:</p>
<pre><code>(set &#39;p (process "rebel"))
(destroy p)
</code></pre>
<h3 id="forking">Forking</h3>
<p>Rebel allows creating a raw OS child process using <code>fork</code>:</p>
<pre><code>(set &#39;pid (fork))
(if (= pid 0)
    (println "child")
    (println "parent"))
</code></pre>
<p>The child has its own execution path and must eventually
exit.</p>
<h3 id="summary-13">Summary</h3>
<p>Process primitives in Rebel provide:</p>
<ul>
<li>external command execution (<code>exec</code>)</li>
<li>bidirectional pipes and raw IPC (<code>pipe</code>)</li>
<li>embedded child interpreters (<code>process</code>)</li>
<li>asynchronous parallel execution (<code>spawn</code>, <code>sync</code>)</li>
<li>inter-process messaging (<code>send</code>, <code>receive</code>)</li>
<li>shared-memory variables (<code>share</code>)</li>
<li>classic process operations (<code>fork</code>, <code>wait-pid</code>, <code>destroy</code>, <code>abort</code>)</li>
</ul>
<p>The model stays close to Unix: explicit, minimal, and fully
under user control.</p>
<h2 id="networking">Networking</h2>
<p>Rebel provides direct access to TCP, UDP, and raw socket
communication.  The network API is thin and close to the
operating system, exposing socket creation, connection, data
transfer, and event polling.  This enables writing low-level
network tools without additional libraries.</p>
<p>Rebel does not hide networking details—ports, addresses, and
sockets are explicit objects.</p>
<h3 id="connecting-to-a-remote-host-net-connect">Connecting to a Remote Host: net-connect</h3>
<p><code>net-connect</code> opens a TCP connection:</p>
<pre><code>(set &#39;s (net-connect "example.com" 80))
(write-line s "GET &#47; HTTP&#47;1.0\n")
(read-line s)
(close s)
</code></pre>
<p>The returned value is a socket handle.</p>
<h3 id="creating-a-server-net-listen-and-net-accept">Creating a Server: net-listen and net-accept</h3>
<p>To create a listening socket:</p>
<pre><code>(set &#39;server (net-listen 8080))
</code></pre>
<p>Accept a client connection:</p>
<pre><code>(set &#39;client (net-accept server))
(write-line client "hello")
(close client)
</code></pre>
<p>This is a blocking call—execution waits for a client to
connect.</p>
<h3 id="sending-and-receiving-data">Sending and Receiving Data</h3>
<p>TCP send:</p>
<pre><code>(net-send s "hello")
</code></pre>
<p>TCP receive:</p>
<pre><code>(net-receive s 64) ; read up to 64 bytes
</code></pre>
<p>UDP send:</p>
<pre><code>(net-send-udp "localhost" 9000 "ping")
</code></pre>
<p>UDP receive:</p>
<pre><code>(net-receive-udp 9000)
</code></pre>
<h3 id="checking-socket-status-net-peek-and-net-select">Checking Socket Status: net-peek and net-select</h3>
<p><code>net-peek</code> returns the number of bytes waiting to be read:</p>
<pre><code>(net-peek s)
</code></pre>
<p><code>net-select</code> checks one or more sockets for activity:</p>
<pre><code>(net-select (list s1 s2) 1000) ; timeout 1000 ms
</code></pre>
<h3 id="network-information-and-tools">Network Information and Tools</h3>
<p>Lookup hostnames:</p>
<pre><code>(net-lookup "8.8.8.8")
</code></pre>
<p>Retrieve local socket info:</p>
<pre><code>(net-local s)
</code></pre>
<p>Get peer address:</p>
<pre><code>(net-peer s)
</code></pre>
<p>Switch between IPv4 and IPv6:</p>
<pre><code>(net-ipv 6)
</code></pre>
<p>Find a port by service name:</p>
<pre><code>(net-service "http") ; -&#62; 80
</code></pre>
<h3 id="raw-packets">Raw Packets</h3>
<p>Rebel can construct and send raw IP packets:</p>
<pre><code>(net-packet "eth0" some-buffer)
```:

This requires appropriate system permissions.


### Remote Evaluation: net-eval

`net-eval` sends an s-expression to a remote Rebel
process for evaluation.  This allows distributed computation
or remote administration.

Basic usage:

</code></pre>
<p>(net-eval &#8220;192.168.1.5&#8221; 4711 &#8216;(+ 1 2)) ; -&#62; 3
```</p>
<p>Broadcast to multiple hosts:</p>
<pre><code>(net-eval &#39;("host1" "host2") 4711 &#39;(now))
</code></pre>
<p>Local parallel evaluation:</p>
<pre><code>(net-eval &#39;(1 2 3 4) (lambda (x) (* x x)))
; -&#62; (1 4 9 16)
</code></pre>
<h3 id="closing-connections">Closing Connections</h3>
<p>Sockets must be closed when no longer needed:</p>
<pre><code>(net-close s)
</code></pre>
<p>This frees the file descriptor.</p>
<h3 id="error-handling">Error Handling</h3>
<p><code>net-error</code> returns the last network error:</p>
<pre><code>(net-error)
</code></pre>
<p>Useful for debugging failed connections or invalid packets.</p>
<h3 id="summary-14">Summary</h3>
<p>Rebel’s networking API provides:</p>
<ul>
<li>direct TCP&#47;UDP socket access<br/></li>
<li>server&#47;client construction<br/></li>
<li>blocking I&#47;O and event polling<br/></li>
<li>hostname and service lookup<br/></li>
<li>raw packet injection<br/></li>
<li>remote evaluation capability<br/></li>
<li>IPv4&#47;IPv6 control<br/></li>
<li>explicit resource management</li>
</ul>
<p>The design follows Unix networking closely: nothing is
abstracted away, giving the programmer full control and
transparency.</p>
<h2 id="http-api">HTTP API</h2>
<p>Rebel includes a compact HTTP utility layer for performing
basic web operations.  </p>
<p>These functions provide simple GET&#47;POST&#47;PUT&#47;DELETE requests,
base64 helpers, and JSON&#47;XML parsing.  The API is
synchronous and follows the Unix philosophy: send a request,
wait for the response, return plain data.</p>
<p>The HTTP API does not attempt to be a full browser or
session manager — it is intended for scripts, automation,
and lightweight integrations.</p>
<h3 id="get-requests-get-url">GET Requests: get-url</h3>
<p>Retrieve the contents of a URL:</p>
<pre><code>(get-url "https:&#47;&#47;example.com")
</code></pre>
<p>The result is a string containing the full response body.
Headers are not provided; this keeps the interface minimal.</p>
<h3 id="post-requests-post-url">POST Requests: post-url</h3>
<p>Send form or structured data to a server:</p>
<pre><code>(post-url "https:&#47;&#47;example.com&#47;submit" "name=ufko&#38;msg=hello")
</code></pre>
<p>The second argument is transmitted as the request body.  The
returned value is the server’s response body.</p>
<h3 id="put-and-delete-put-url-and-delete-url">PUT and DELETE: put-url and delete-url</h3>
<p><code>put-url</code> uploads or replaces a resource:</p>
<pre><code>(put-url "https:&#47;&#47;example.com&#47;update" "new content")
</code></pre>
<p><code>delete-url</code> removes a resource:</p>
<pre><code>(delete-url "https:&#47;&#47;example.com&#47;remove")
</code></pre>
<p>Both return the response body if provided by the server.</p>
<h3 id="base64-encoding-and-decoding">Base64 Encoding and Decoding</h3>
<p>Utility functions for handling base64:</p>
<pre><code>(base64-enc "hello") ; -&#62; "aGVsbG8="
(base64-dec "aGVsbG8=") ; -&#62; "hello"
</code></pre>
<p>Useful for HTTP payloads requiring binary or credential
encoding.</p>
<h3 id="json">JSON</h3>
<p>Parse JSON into Rebel data structures:</p>
<pre><code>(json-parse "{\"a\": 1, \"b\": [2,3]}") 
; -&#62; (("a" 1) ("b" (2 3)))
</code></pre>
<p>If an error occurs, use <code>json-error</code> to inspect it:</p>
<pre><code>(json-error)
</code></pre>
<h3 id="xml">XML</h3>
<p>Parse XML into nested lists:</p>
<pre><code>(xml-parse "&#60;root&#62;&#60;x&#62;10&#60;&#47;x&#62;&#60;&#47;root&#62;")
</code></pre>
<p>If parsing fails:</p>
<pre><code>(xml-error)
</code></pre>
<p><code>xml-type-tags</code> controls tag and attribute formatting rules.</p>
<h3 id="uploading-and-handling-events">Uploading and Handling Events</h3>
<p>During long data transfers, HTTP utilities can emit progress
events.  You can register a handler:</p>
<pre><code>(xfer-event (lambda (bytes) (println "transferred:" bytes)))
</code></pre>
<p>This is optional and used only for larger uploads or
downloads.</p>
<h3 id="error-handling-1">Error Handling</h3>
<p>Invalid URLs, network failures, incorrect content types, and
protocol errors return <code>nil</code>.  For debugging, use:</p>
<pre><code>(net-error)
</code></pre>
<p>to inspect the underlying system-level error.</p>
<h3 id="security-notes">Security Notes</h3>
<p>The HTTP API provides no cookie store, authentication
helpers, or TLS inspection.  TLS support depends on the
underlying system libraries.  This is intentional — Rebel
leaves control to the user and avoids hidden state.</p>
<h3 id="summary-15">Summary</h3>
<p>The HTTP API offers:</p>
<ul>
<li>GET&#47;POST&#47;PUT&#47;DELETE helpers<br/></li>
<li>base64 encoding&#47;decoding<br/></li>
<li>JSON and XML parsing<br/></li>
<li>transfer event hooks<br/></li>
<li>raw string-based responses<br/></li>
<li>simple synchronous model<br/></li>
</ul>
<p>It is intentionally minimal, making HTTP scripting
straightforward without adding a complex client layer.</p>
<h2 id="date-and-time">Date and Time</h2>
<p>Rebel provides a compact set of functions for working with
dates, timestamps, and elapsed time.  The API is simple and
intentionally limited: the goal is to give scripts access to
clock values, formatted strings, and conversions, not to
recreate a full calendar system.</p>
<p>Rebel measures time in <strong>seconds since the Unix epoch</strong>
(January 1, 1970), returned as integers or floats depending
on context.</p>
<h3 id="current-time-now">Current Time: now</h3>
<p><code>now</code> returns a list containing the current date and time
components:</p>
<pre><code>(now)
; -&#62; (year month day hour minute second)
</code></pre>
<p>The returned list is suitable for logging, timestamps, or
building custom formats.</p>
<h3 id="formatting-time-date">Formatting Time: date</h3>
<p><code>date</code> converts a timestamp into a human-readable string.<br/>
If no argument is given, it formats the current time.</p>
<pre><code>(date)                ; current time as string
(date 1700000000)     ; format specific timestamp
</code></pre>
<p>The exact format depends on the underlying system locale.</p>
<h3 id="parsing-date-strings-date-parse">Parsing Date Strings: date-parse</h3>
<p><code>date-parse</code> converts a date string into a Unix timestamp:</p>
<pre><code>(date-parse "2025-02-15 12:30:00")
</code></pre>
<p>The accepted formats vary by platform but typically include
ISO-like representations.  If the string cannot be parsed,
the result is <code>nil</code>.</p>
<h3 id="converting-components-to-timestamp-date-value">Converting Components to Timestamp: date-value</h3>
<p><code>date-value</code> takes individual components and returns a timestamp:</p>
<pre><code>(date-value 2025 1 1 0 0 0)
; -&#62; seconds since epoch
</code></pre>
<p>This is the inverse of <code>now</code>: instead of extracting
components from a timestamp, you build a timestamp from
components.</p>
<h3 id="elapsed-time-time">Elapsed Time: time</h3>
<p><code>time</code> measures the duration required to evaluate an
expression.  The result is milliseconds.</p>
<pre><code>(time (sleep 200)) ; -&#62; about 200
</code></pre>
<p>Useful for profiling or measuring performance
characteristics.</p>
<h3 id="milliseconds-since-start-of-day-time-of-day">Milliseconds Since Start of Day: time-of-day</h3>
<p><code>time-of-day</code> returns the number of milliseconds since
midnight:</p>
<pre><code>(time-of-day)
</code></pre>
<p>This is often used for sampling, animations, periodic
events, or time-based calculations where only the current
day matters.</p>
<h3 id="examples">Examples</h3>
<p>Getting the current hour:</p>
<pre><code>(nth 3 (now))
</code></pre>
<p>Time difference between two events:</p>
<pre><code>(set &#39;t1 (date-parse "2025-01-01 12:00:00"))
(set &#39;t2 (date-parse "2025-01-01 14:00:00"))
(- t2 t1) ; -&#62; 7200 seconds
</code></pre>
<p>Formatting a custom date:</p>
<pre><code>(set &#39;ts (date-value 2030 12 24 18 0 0))
(date ts)
</code></pre>
<h3 id="summary-16">Summary</h3>
<p>Rebel’s date&#47;time facilities provide:</p>
<ul>
<li>current local date and time via <code>now</code><br/></li>
<li>timestamp formatting with <code>date</code><br/></li>
<li>parsing date strings using <code>date-parse</code><br/></li>
<li>constructing timestamps with <code>date-value</code><br/></li>
<li>timing expressions with <code>time</code><br/></li>
<li>day-relative milliseconds via <code>time-of-day</code><br/></li>
</ul>
<p>The system is intentionally small and transparent, giving
scripts easy access to essential clock operations without
unnecessary complexity.</p>
<h2 id="math-and-numbers">Math and Numbers</h2>
<p>Rebel includes a comprehensive set of numeric functions
covering integer arithmetic, floating-point operations,
logarithms, trigonometry, probability tools, special
functions, and random number generation.  The model is
simple: numbers evaluate to themselves, operations are
normal function calls, and all numeric values are immutable.</p>
<p>Rebel supports both integers and IEEE floating-point
numbers.  Most arithmetic functions accept either type and
return the most appropriate numeric form.</p>
<h3 id="integer-arithmetic">Integer Arithmetic</h3>
<p>Basic operations:</p>
<pre><code>(+ 1 2) ; -&#62; 3
(- 7 3) ; -&#62; 4
(* 3 4) ; -&#62; 12
(&#47; 10 2) ; -&#62; 5
(% 10 3) ; -&#62; 1
</code></pre>
<p>Comparison operators:</p>
<pre><code>(&#60; 2 5)   ; -&#62; true
(&#62;= 7 7)  ; -&#62; true
(!= 3 4)  ; -&#62; true
</code></pre>
<p>Increment&#47;decrement operations:</p>
<pre><code>(inc x)   ; increments symbol x
(dec x)   ; decrements symbol x
(++ 10)   ; -&#62; 11  ; returns new value
(-- 10)   ; -&#62; 9
</code></pre>
<h3 id="floating-point-operations">Floating-Point Operations</h3>
<p>Many numeric functions automatically return floats:</p>
<pre><code>(add 1 2.5) ; -&#62; 3.5
(sub 5 2.2) ; -&#62; 2.8
(mul 2 0.5) ; -&#62; 1.0
(div 7 2)   ; -&#62; 3.5
</code></pre>
<p><code>flt</code> converts a number into its 32-bit float
representation, mainly for FFI.</p>
<h3 id="exponentials-and-logarithms">Exponentials and Logarithms</h3>
<pre><code>(exp 1)     ; -&#62; 2.718281828
(log 10)    ; natural log
(log 100 10) ; log base 10
(pow 2 8)   ; -&#62; 256
</code></pre>
<h3 id="trigonometry">Trigonometry</h3>
<p>Standard trigonometric and hyperbolic functions:</p>
<pre><code>(sin 0)     ; -&#62; 0
(cos 0)     ; -&#62; 1
(tan 0.5)
(asin 0.5)
(acos 0.4)
(atan 1)
(sinh 1)
(cosh 1)
(tanh 1)
(atan2 y x)
</code></pre>
<h3 id="special-functions">Special Functions</h3>
<p>Rebel includes a full suite of mathematical special
functions.</p>
<p>Gamma and Beta:</p>
<pre><code>(gammaln 5)
(beta 1 2)
(betai 0.5 2 3)
</code></pre>
<p>Error function:</p>
<pre><code>(erf 1)
</code></pre>
<p>Binomial and factorial-like tools:</p>
<pre><code>(binomial 5 2) ; -&#62; 10
(factor 84)    ; -&#62; (2 2 3 7)
</code></pre>
<h3 id="rounding-and-sign">Rounding and Sign</h3>
<pre><code>(floor 3.7) ; -&#62; 3
(ceil  3.1) ; -&#62; 4
(round 2.49) ; -&#62; 2
(sgn -5)     ; -&#62; -1
</code></pre>
<p><code>inf?</code> tests for infinity, <code>NaN?</code> checks for invalid floats.</p>
<h3 id="statistical-tools">Statistical Tools</h3>
<p>A collection of functions useful for probability work:</p>
<pre><code>(normal 5 2) ; generates a list of 5 normally-distributed floats
(stats &#39;(1 2 3 4 5))
(corr &#39;(1 2 3) &#39;(2 4 6))
</code></pre>
<p>Critical distributions:</p>
<pre><code>(crit-z 0.95)
(crit-t 10 0.95)
(crit-chi2 4 0.95)
</code></pre>
<h3 id="random-numbers">Random Numbers</h3>
<p><code>rand</code> generates integers:</p>
<pre><code>(rand 10) ; -&#62; integer in range [0,10)
</code></pre>
<p><code>random</code> generates floating-point ranges:</p>
<pre><code>(random 3) ; -&#62; list of 3 floats in [0,1)
</code></pre>
<p><code>randomize</code> shuffles elements of a list:</p>
<pre><code>(randomize &#39;(a b c d))
</code></pre>
<p>Seed control:</p>
<pre><code>(seed 123)
</code></pre>
<h3 id="modulo-and-gcd">Modulo and GCD</h3>
<pre><code>(mod 10 3) ; -&#62; 1
(gcd 24 60) ; -&#62; 12
</code></pre>
<h3 id="vector-and-series-utilities">Vector and Series Utilities</h3>
<pre><code>(sequence 1 5) ; -&#62; (1 2 3 4 5)
(series 1.0 1.5 5) ; geometric or arithmetic progression
(ssq &#39;(1 2 3)) ; sum of squares
</code></pre>
<h3 id="summary-17">Summary</h3>
<p>Rebel’s numeric system provides:</p>
<ul>
<li>full integer and floating-point arithmetic<br/></li>
<li>logarithmic, exponential, and power functions<br/></li>
<li>complete trigonometry and hyperbolic functions<br/></li>
<li>advanced special functions (gamma, beta, erf, etc.)<br/></li>
<li>statistical and probabilistic tools<br/></li>
<li>random number generators and shuffling<br/></li>
<li>rounding, sign, GCD, modulo operations<br/></li>
</ul>
<p>The model remains minimal and consistent: numbers evaluate
to themselves, operations are explicit function calls, and
results follow clear numerical rules.</p>
<h2 id="predicates">Predicates</h2>
<p>Predicates are functions that answer a yes&#47;no question about a value.<br/>
They return <code>true</code> when the condition holds, otherwise <code>nil</code>.<br/>
Rebel relies heavily on predicates because flow-control constructs treat any
non-nil value as true.</p>
<p>Predicates cover type checks, numeric tests, emptiness, structural queries, and
special conditions like NaN or infinity.</p>
<h3 id="type-predicates">Type Predicates</h3>
<p>These predicates check the fundamental type of a value:</p>
<pre><code>(number? 10)        ; -&#62; true
(integer? 10)       ; -&#62; true
(float? 3.14)       ; -&#62; true
(string? "x")       ; -&#62; true
(list? &#39;(1 2 3))    ; -&#62; true
(array? (array 3))  ; -&#62; true
(symbol? &#39;a)        ; -&#62; true
(context? MAIN)     ; -&#62; true
</code></pre>
<p>Some values satisfy multiple predicates (e.g., integers are also numbers).</p>
<h3 id="numeric-predicates">Numeric Predicates</h3>
<p>Check numeric properties:</p>
<pre><code>(even? 4) ; -&#62; true
(odd? 5)  ; -&#62; true
(zero? 0) ; -&#62; true
(zero? 0.0) ; -&#62; true
</code></pre>
<p>Sign and special cases:</p>
<pre><code>(inf? (&#47; 1 0.0)) ; -&#62; true
(NaN? (&#47; 0.0 0.0)) ; -&#62; true
</code></pre>
<h3 id="existence-and-emptiness">Existence and Emptiness</h3>
<pre><code>(empty? &#39;())   ; -&#62; true
(empty? "")    ; -&#62; true
(nil? nil)     ; -&#62; true
(null? 0)      ; -&#62; true  ; null? treats 0, "", (), nil, 0.0 as null
</code></pre>
<p><code>true?</code> checks for any non-nil value:</p>
<pre><code>(true? 5)     ; -&#62; true
(true? nil)   ; -&#62; nil
</code></pre>
<h3 id="structural-predicates">Structural Predicates</h3>
<p>Membership:</p>
<pre><code>(member &#39;b &#39;(a b c)) ; -&#62; true
</code></pre>
<p>Lookup-style predicates:</p>
<pre><code>(global? &#39;x)     ; checks if symbol is global
(protected? &#39;y)  ; symbol protection flag
</code></pre>
<h3 id="symbol-and-quoting-predicates">Symbol and Quoting Predicates</h3>
<p>These detect quoting and symbolic state:</p>
<pre><code>(quote? &#39;(1 2 3)) ; -&#62; true if explicitly quoted
(symbol? &#39;x)      ; -&#62; true
</code></pre>
<p><code>legal?</code> checks if a string can be turned into a symbol:</p>
<pre><code>(legal? "abc")    ; -&#62; true
(legal? "1abc")   ; -&#62; nil
</code></pre>
<h3 id="file-and-directory-predicates">File and Directory Predicates</h3>
<pre><code>(file? "data.txt")     ; -&#62; true if file exists
(directory? "&#47;tmp")    ; -&#62; true if directory exists
</code></pre>
<h3 id="system-level-predicates">System-Level Predicates</h3>
<p>Check platform or symbol characteristics:</p>
<pre><code>(lambda? (lambda (x) x)) ; -&#62; true
(macro?  some-macro)     ; -&#62; true if macro
(primitive? +)           ; -&#62; true
</code></pre>
<p>Test if a symbol has any binding at all:</p>
<pre><code>(nil? (eval &#39;unknown)) ; error for unbound symbol
</code></pre>
<p>To avoid errors, combine with <code>global?</code> or store in lookup tables.</p>
<h3 id="predicate-use-in-flow-control">Predicate Use in Flow Control</h3>
<p>Predicates integrate naturally with <code>if</code>, <code>when</code>, <code>unless</code>, and loops:</p>
<pre><code>(when (empty? lst)
  (println "list is empty"))
</code></pre>
<p>Any non-nil value counts as true; <code>nil</code> counts as false.</p>
<h3 id="summary-18">Summary</h3>
<p>Predicate functions in Rebel provide:</p>
<ul>
<li>type checks for numbers, lists, strings, arrays, symbols, contexts<br/></li>
<li>numeric property checks (even?, odd?, zero?, inf?, NaN?)<br/></li>
<li>structural checks (member, empty?, null?)<br/></li>
<li>file and directory status<br/></li>
<li>symbol introspection (lambda?, macro?, primitive?, global?, protected?)<br/></li>
<li>quoting and legal symbol detection<br/></li>
</ul>
<p>Predicates keep control flow simple and expressive, letting code declare its
intent with minimal ceremony.</p>
<h2 id="system-interface">System Interface</h2>
<p>Rebel exposes a compact system interface for interacting
with the underlying operating system.  These functions
provide access to environment variables, process
information, signal handling, system resources, and program
arguments.  The design is minimal: no layers, no wrappers —
direct access to OS behavior.</p>
<p>System functions are essential for scripting, automation,
and embedding Rebel in Unix workflows.</p>
<h3 id="environment-variables-env">Environment Variables: env</h3>
<p>Read or set environment variables:</p>
<pre><code>(env "HOME")          ; read
(env "MYVAR" "hello") ; set
</code></pre>
<p>To list all environment variables:</p>
<pre><code>(env)
</code></pre>
<h3 id="program-arguments-main-args">Program Arguments: main-args</h3>
<p>Fetch arguments passed to the Rebel interpreter:</p>
<pre><code>(main-args)
; -&#62; ("script.reb" "arg1" "arg2")
</code></pre>
<p>This is useful when writing executable scripts.</p>
<h3 id="exiting-the-interpreter-exit">Exiting the Interpreter: exit</h3>
<p>Terminate execution with a return code:</p>
<pre><code>(exit 0)
</code></pre>
<p>A non-zero value signals failure:</p>
<pre><code>(exit 1)
</code></pre>
<h3 id="system-information-sys-info">System Information: sys-info</h3>
<p><code>sys-info</code> retrieves platform and interpreter information.<br/>
Selected fields include memory usage, system type, process ID, etc.</p>
<pre><code>(sys-info)
</code></pre>
<p>Platform type only:</p>
<pre><code>(ostype) ; -&#62; string describing OS
</code></pre>
<h3 id="error-handling-last-error-and-sys-error">Error Handling: last-error and sys-error</h3>
<p><code>last-error</code> returns the last error number and message
raised by Rebel:</p>
<pre><code>(last-error)
</code></pre>
<p><code>sys-error</code> returns the most recent OS-level error:</p>
<pre><code>(sys-error)
</code></pre>
<h3 id="signals-signal">Signals: signal</h3>
<p>Install a custom handler for OS signals:</p>
<pre><code>(signal 2 (lambda () (println "caught interrupt")))
</code></pre>
<p>For example, signal 2 is typically CTRL-C (SIGINT).<br/>
A handler may return or terminate the program.</p>
<h3 id="sleeping-sleep">Sleeping: sleep</h3>
<p>Pause execution for a number of milliseconds:</p>
<pre><code>(sleep 500) ; half second
</code></pre>
<p>This is useful for throttling, polling, or simple timing
logic.</p>
<h3 id="default-functor-default">Default Functor: default</h3>
<p>Retrieve or set the default functor in a context:</p>
<pre><code>(default &#39;Math) ; returns default symbol of Math context
</code></pre>
<p>This is a specialized feature used mainly when building
DSL-like constructs.</p>
<h3 id="printing-and-formatting-pretty-print">Printing and Formatting: pretty-print</h3>
<p>Configure how lists and expressions are printed:</p>
<pre><code>(pretty-print true)
</code></pre>
<p>Useful for debugging large nested structures.</p>
<h3 id="history-and-tracing">History and Tracing</h3>
<p><code>history</code> returns the call history of a function:</p>
<pre><code>(history some-function)
</code></pre>
<p><code>trace</code> enables tracing:</p>
<pre><code>(trace true)
</code></pre>
<p><code>trace-highlight</code> customizes colors or markers used during
tracing:</p>
<pre><code>(trace-highlight "[[" "]]")
</code></pre>
<h3 id="reading-expressions-without-evaluating-read-expr">Reading Expressions Without Evaluating: read-expr</h3>
<p>Convert a string into an s-expression without evaluating it:</p>
<pre><code>(read-expr "(+ 1 2)")
; -&#62; (+ 1 2)
</code></pre>
<h3 id="locale-and-character-settings-set-locale">Locale and Character Settings: set-locale</h3>
<p>Change locale-dependent behavior:</p>
<pre><code>(set-locale "en_US.UTF-8")
</code></pre>
<p>This affects number formatting, date output, and some string
operations.</p>
<h3 id="resetting-to-top-level-reset">Resetting to Top Level: reset</h3>
<p>Abort the current evaluation and return to the REPL top
level:</p>
<pre><code>(reset)
</code></pre>
<p>Useful in interactive sessions.</p>
<h3 id="summary-19">Summary</h3>
<p>The System Interface provides:</p>
<ul>
<li>environment variable access (<code>env</code>)</li>
<li>command-line argument retrieval (<code>main-args</code>)</li>
<li>interpreter control (<code>exit</code>, <code>reset</code>)</li>
<li>system&#47;error inspection (<code>sys-info</code>, <code>last-error</code>, <code>sys-error</code>, <code>ostype</code>)</li>
<li>signal handling (<code>signal</code>)</li>
<li>timing utilities (<code>sleep</code>)</li>
<li>printing and introspection tools (<code>pretty-print</code>, <code>trace</code>, <code>history</code>)</li>
<li>safe expression parsing (<code>read-expr</code>)</li>
<li>locale configuration (<code>set-locale</code>)</li>
</ul>
<p>These functions connect Rebel to the operating system
directly, keeping scripts simple, transparent, and tightly
integrated with Unix behavior.</p>
<h2 id="internals">Internals</h2>
<p>Internals expose the low-level mechanisms of the Rebel
interpreter.  These functions operate below the normal
language layer and allow you to:</p>
<ul>
<li>intercept input before evaluation<br/></li>
<li>rewrite expressions on the fly<br/></li>
<li>customize the REPL<br/></li>
<li>inspect or copy raw memory<br/></li>
<li>work with binary structures<br/></li>
<li>import C functions via shared libraries<br/></li>
</ul>
<p>These tools are powerful and should be used carefully, as
they interact directly with the interpreter’s internal
state.</p>
<h3 id="reader-level-hooks">Reader-Level Hooks</h3>
<p>Rebel provides several hooks that run during expression
parsing and evaluation.</p>
<h3 id="reader-event">reader-event</h3>
<p><code>reader-event</code> installs a callback that receives each
incoming expression <em>before</em> evaluation.  You can rewrite or
transform expressions here.</p>
<pre><code>(reader-event (lambda (expr)
  (println "raw:" expr)
  expr))  ; return the expression unchanged
</code></pre>
<p>Returning a modified expression alters execution.<br/>
Returning nil causes an empty evaluation.</p>
<h3 id="command-event">command-event</h3>
<p><code>command-event</code> processes command-line input when Rebel is
started with arguments or when handling HTTP script
execution.</p>
<pre><code>(command-event (lambda (args)
  (println "command args:" args)
  args))
</code></pre>
<p>Typically used in CGI-like environments or tooling automation.</p>
<h3 id="prompt-event">prompt-event</h3>
<p>Customize the interactive REPL prompt:</p>
<pre><code>(prompt-event (lambda () "rebel&#62; "))
</code></pre>
<p>The function must return a string.</p>
<h3 id="read-expr">read-expr</h3>
<p>Convert a string into an s-expression without evaluating it:</p>
<pre><code>(read-expr "(+ 1 2)") ; -&#62; (+ 1 2)
</code></pre>
<p>This is the safe alternative to <code>eval</code> when parsing external data.</p>
<h3 id="memory-inspection">Memory Inspection</h3>
<p>These functions operate on raw memory addresses.<br/>
Use them only when absolutely necessary.</p>
<h3 id="cpymem">cpymem</h3>
<p>Copy bytes between memory locations:</p>
<pre><code>(cpymem dest src 32)
</code></pre>
<p>This is mainly useful in FFI wrappers or binary manipulation.</p>
<h3 id="dump">dump</h3>
<p>Debug memory contents:</p>
<pre><code>(dump some-value)
</code></pre>
<p>Used for inspecting internal cell layout.  Mostly relevant
to implementers or advanced debugging.</p>
<h3 id="binary-packing">Binary Packing</h3>
<p>Rebel can serialize and deserialize binary structs.</p>
<h3 id="pack">pack</h3>
<p>Pack values according to a type specification:</p>
<pre><code>(pack "iCf" 100 65 3.14)
</code></pre>
<p>Types follow a compact signature:<br/>
<code>i</code>=int, <code>C</code>=char, <code>f</code>=float, etc.</p>
<h3 id="unpack">unpack</h3>
<p>Reverse operation:</p>
<pre><code>(unpack "iCf" buffer)
</code></pre>
<p>Useful for binary protocols and custom serialization
formats.</p>
<h3 id="struct">struct</h3>
<p>Define a reusable C-struct layout:</p>
<pre><code>(struct Point (int x) (int y))
</code></pre>
<p>This creates pack&#47;unpack helpers for the structure.</p>
<h3 id="foreign-function-interface-ffi">Foreign Function Interface (FFI)</h3>
<p>Rebel can dynamically import shared library functions and
call them directly.</p>
<h3 id="import">import</h3>
<p>Import a function from a shared library:</p>
<pre><code>(import "libm.so" "cos" "double" "double")
(cos 0.0)
</code></pre>
<p>Format:<br/>
<code>(import library function return-type arg1-type arg2-type ...)</code></p>
<h3 id="callback">callback</h3>
<p>Register a Rebel function as a C callback:</p>
<pre><code>(define (cb x) (+ x 1))
(callback cb)
</code></pre>
<p>The returned pointer can be passed to a C function expecting
a callback.</p>
<h3 id="address-get--set-">address, get-<em>, set-</em></h3>
<p>Retrieve raw memory addresses or interpret memory as typed
values:</p>
<pre><code>(address "hello")
(get-int ptr)
(get-string ptr)
</code></pre>
<p>These enable low-level interop but require careful handling.</p>
<h3 id="internals-and-safety">Internals and Safety</h3>
<p>Internal primitives bypass many of Rebel’s safety checks.
You can:</p>
<ul>
<li>rewrite evaluation results<br/></li>
<li>bypass normal scoping<br/></li>
<li>manipulate raw memory<br/></li>
<li>construct invalid binary data<br/></li>
<li>call arbitrary C functions<br/></li>
</ul>
<p>Use them sparingly and isolate such code into small,
well-understood modules.</p>
<h3 id="summary-20">Summary</h3>
<p>Internals provide:</p>
<ul>
<li>expression interception (<code>reader-event</code>, <code>command-event</code>)<br/></li>
<li>REPL customization (<code>prompt-event</code>)<br/></li>
<li>safe parsing (<code>read-expr</code>)<br/></li>
<li>raw memory tools (<code>cpymem</code>, <code>dump</code>, address getters)<br/></li>
<li>binary pack&#47;unpack facilities<br/></li>
<li>struct definitions for binary layouts<br/></li>
<li>full FFI support through <code>import</code> and <code>callback</code><br/></li>
</ul>
<p>These tools unlock Rebel’s low-level capabilities, bridging
high-level Lisp-like code with system and native C
functionality.</p>

</body>
</html>
